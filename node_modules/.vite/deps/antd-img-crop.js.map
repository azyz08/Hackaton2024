{
  "version": 3,
  "sources": ["../../normalize-wheel/src/UserAgent_DEPRECATED.js", "../../normalize-wheel/src/ExecutionEnvironment.js", "../../normalize-wheel/src/isEventSupported.js", "../../normalize-wheel/src/normalizeWheel.js", "../../normalize-wheel/index.js", "../../antd-img-crop/dist/antd-img-crop.esm.js", "../../compare-versions/src/utils.ts", "../../compare-versions/src/compareVersions.ts", "../../compare-versions/src/compare.ts", "../../src/helpers.ts", "../../src/Cropper.tsx"],
<<<<<<< HEAD
  "sourcesContent": ["/**\r\n * Copyright 2004-present Facebook. All Rights Reserved.\r\n *\r\n * @providesModule UserAgent_DEPRECATED\r\n */\r\n\r\n/**\r\n *  Provides entirely client-side User Agent and OS detection. You should prefer\r\n *  the non-deprecated UserAgent module when possible, which exposes our\r\n *  authoritative server-side PHP-based detection to the client.\r\n *\r\n *  Usage is straightforward:\r\n *\r\n *    if (UserAgent_DEPRECATED.ie()) {\r\n *      //  IE\r\n *    }\r\n *\r\n *  You can also do version checks:\r\n *\r\n *    if (UserAgent_DEPRECATED.ie() >= 7) {\r\n *      //  IE7 or better\r\n *    }\r\n *\r\n *  The browser functions will return NaN if the browser does not match, so\r\n *  you can also do version compares the other way:\r\n *\r\n *    if (UserAgent_DEPRECATED.ie() < 7) {\r\n *      //  IE6 or worse\r\n *    }\r\n *\r\n *  Note that the version is a float and may include a minor version number,\r\n *  so you should always use range operators to perform comparisons, not\r\n *  strict equality.\r\n *\r\n *  **Note:** You should **strongly** prefer capability detection to browser\r\n *  version detection where it's reasonable:\r\n *\r\n *    http://www.quirksmode.org/js/support.html\r\n *\r\n *  Further, we have a large number of mature wrapper functions and classes\r\n *  which abstract away many browser irregularities. Check the documentation,\r\n *  grep for things, or ask on javascript@lists.facebook.com before writing yet\r\n *  another copy of \"event || window.event\".\r\n *\r\n */\r\n\r\nvar _populated = false;\r\n\r\n// Browsers\r\nvar _ie, _firefox, _opera, _webkit, _chrome;\r\n\r\n// Actual IE browser for compatibility mode\r\nvar _ie_real_version;\r\n\r\n// Platforms\r\nvar _osx, _windows, _linux, _android;\r\n\r\n// Architectures\r\nvar _win64;\r\n\r\n// Devices\r\nvar _iphone, _ipad, _native;\r\n\r\nvar _mobile;\r\n\r\nfunction _populate() {\r\n  if (_populated) {\r\n    return;\r\n  }\r\n\r\n  _populated = true;\r\n\r\n  // To work around buggy JS libraries that can't handle multi-digit\r\n  // version numbers, Opera 10's user agent string claims it's Opera\r\n  // 9, then later includes a Version/X.Y field:\r\n  //\r\n  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10\r\n  var uas = navigator.userAgent;\r\n  var agent = /(?:MSIE.(\\d+\\.\\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\\d+\\.\\d+))|(?:Opera(?:.+Version.|.)(\\d+\\.\\d+))|(?:AppleWebKit.(\\d+(?:\\.\\d+)?))|(?:Trident\\/\\d+\\.\\d+.*rv:(\\d+\\.\\d+))/.exec(uas);\r\n  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);\r\n\r\n  _iphone = /\\b(iPhone|iP[ao]d)/.exec(uas);\r\n  _ipad = /\\b(iP[ao]d)/.exec(uas);\r\n  _android = /Android/i.exec(uas);\r\n  _native = /FBAN\\/\\w+;/i.exec(uas);\r\n  _mobile = /Mobile/i.exec(uas);\r\n\r\n  // Note that the IE team blog would have you believe you should be checking\r\n  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming\r\n  // from either x64 or ia64;  so ultimately, you should just check for Win64\r\n  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit\r\n  // Windows will send 'WOW64' instead.\r\n  _win64 = !!(/Win64/.exec(uas));\r\n\r\n  if (agent) {\r\n    _ie = agent[1] ? parseFloat(agent[1]) : (\r\n          agent[5] ? parseFloat(agent[5]) : NaN);\r\n    // IE compatibility mode\r\n    if (_ie && document && document.documentMode) {\r\n      _ie = document.documentMode;\r\n    }\r\n    // grab the \"true\" ie version from the trident token if available\r\n    var trident = /(?:Trident\\/(\\d+.\\d+))/.exec(uas);\r\n    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;\r\n\r\n    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;\r\n    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;\r\n    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;\r\n    if (_webkit) {\r\n      // We do not add the regexp to the above test, because it will always\r\n      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in\r\n      // the userAgent string.\r\n      agent = /(?:Chrome\\/(\\d+\\.\\d+))/.exec(uas);\r\n      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;\r\n    } else {\r\n      _chrome = NaN;\r\n    }\r\n  } else {\r\n    _ie = _firefox = _opera = _chrome = _webkit = NaN;\r\n  }\r\n\r\n  if (os) {\r\n    if (os[1]) {\r\n      // Detect OS X version.  If no version number matches, set _osx to true.\r\n      // Version examples:  10, 10_6_1, 10.7\r\n      // Parses version number as a float, taking only first two sets of\r\n      // digits.  If only one set of digits is found, returns just the major\r\n      // version number.\r\n      var ver = /(?:Mac OS X (\\d+(?:[._]\\d+)?))/.exec(uas);\r\n\r\n      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;\r\n    } else {\r\n      _osx = false;\r\n    }\r\n    _windows = !!os[2];\r\n    _linux   = !!os[3];\r\n  } else {\r\n    _osx = _windows = _linux = false;\r\n  }\r\n}\r\n\r\nvar UserAgent_DEPRECATED = {\r\n\r\n  /**\r\n   *  Check if the UA is Internet Explorer.\r\n   *\r\n   *\r\n   *  @return float|NaN Version number (if match) or NaN.\r\n   */\r\n  ie: function() {\r\n    return _populate() || _ie;\r\n  },\r\n\r\n  /**\r\n   * Check if we're in Internet Explorer compatibility mode.\r\n   *\r\n   * @return bool true if in compatibility mode, false if\r\n   * not compatibility mode or not ie\r\n   */\r\n  ieCompatibilityMode: function() {\r\n    return _populate() || (_ie_real_version > _ie);\r\n  },\r\n\r\n\r\n  /**\r\n   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we\r\n   * only need this because Skype can't handle 64-bit IE yet.  We need to remove\r\n   * this when we don't need it -- tracked by #601957.\r\n   */\r\n  ie64: function() {\r\n    return UserAgent_DEPRECATED.ie() && _win64;\r\n  },\r\n\r\n  /**\r\n   *  Check if the UA is Firefox.\r\n   *\r\n   *\r\n   *  @return float|NaN Version number (if match) or NaN.\r\n   */\r\n  firefox: function() {\r\n    return _populate() || _firefox;\r\n  },\r\n\r\n\r\n  /**\r\n   *  Check if the UA is Opera.\r\n   *\r\n   *\r\n   *  @return float|NaN Version number (if match) or NaN.\r\n   */\r\n  opera: function() {\r\n    return _populate() || _opera;\r\n  },\r\n\r\n\r\n  /**\r\n   *  Check if the UA is WebKit.\r\n   *\r\n   *\r\n   *  @return float|NaN Version number (if match) or NaN.\r\n   */\r\n  webkit: function() {\r\n    return _populate() || _webkit;\r\n  },\r\n\r\n  /**\r\n   *  For Push\r\n   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit\r\n   */\r\n  safari: function() {\r\n    return UserAgent_DEPRECATED.webkit();\r\n  },\r\n\r\n  /**\r\n   *  Check if the UA is a Chrome browser.\r\n   *\r\n   *\r\n   *  @return float|NaN Version number (if match) or NaN.\r\n   */\r\n  chrome : function() {\r\n    return _populate() || _chrome;\r\n  },\r\n\r\n\r\n  /**\r\n   *  Check if the user is running Windows.\r\n   *\r\n   *  @return bool `true' if the user's OS is Windows.\r\n   */\r\n  windows: function() {\r\n    return _populate() || _windows;\r\n  },\r\n\r\n\r\n  /**\r\n   *  Check if the user is running Mac OS X.\r\n   *\r\n   *  @return float|bool   Returns a float if a version number is detected,\r\n   *                       otherwise true/false.\r\n   */\r\n  osx: function() {\r\n    return _populate() || _osx;\r\n  },\r\n\r\n  /**\r\n   * Check if the user is running Linux.\r\n   *\r\n   * @return bool `true' if the user's OS is some flavor of Linux.\r\n   */\r\n  linux: function() {\r\n    return _populate() || _linux;\r\n  },\r\n\r\n  /**\r\n   * Check if the user is running on an iPhone or iPod platform.\r\n   *\r\n   * @return bool `true' if the user is running some flavor of the\r\n   *    iPhone OS.\r\n   */\r\n  iphone: function() {\r\n    return _populate() || _iphone;\r\n  },\r\n\r\n  mobile: function() {\r\n    return _populate() || (_iphone || _ipad || _android || _mobile);\r\n  },\r\n\r\n  nativeApp: function() {\r\n    // webviews inside of the native apps\r\n    return _populate() || _native;\r\n  },\r\n\r\n  android: function() {\r\n    return _populate() || _android;\r\n  },\r\n\r\n  ipad: function() {\r\n    return _populate() || _ipad;\r\n  }\r\n};\r\n\r\nmodule.exports = UserAgent_DEPRECATED;\r\n", "/**\r\n * Copyright (c) 2015, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule ExecutionEnvironment\r\n */\r\n\r\n/*jslint evil: true */\r\n\r\n'use strict';\r\n\r\nvar canUseDOM = !!(\r\n  typeof window !== 'undefined' &&\r\n  window.document &&\r\n  window.document.createElement\r\n);\r\n\r\n/**\r\n * Simple, lightweight module assisting with the detection and context of\r\n * Worker. Helps avoid circular dependencies and allows code to reason about\r\n * whether or not they are in a Worker, even if they never include the main\r\n * `ReactWorker` dependency.\r\n */\r\nvar ExecutionEnvironment = {\r\n\r\n  canUseDOM: canUseDOM,\r\n\r\n  canUseWorkers: typeof Worker !== 'undefined',\r\n\r\n  canUseEventListeners:\r\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\r\n\r\n  canUseViewport: canUseDOM && !!window.screen,\r\n\r\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\r\n\r\n};\r\n\r\nmodule.exports = ExecutionEnvironment;\r\n", "/**\r\n * Copyright 2013-2015, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule isEventSupported\r\n */\r\n\r\n'use strict';\r\n\r\nvar ExecutionEnvironment = require('./ExecutionEnvironment');\r\n\r\nvar useHasFeature;\r\nif (ExecutionEnvironment.canUseDOM) {\r\n  useHasFeature =\r\n    document.implementation &&\r\n    document.implementation.hasFeature &&\r\n    // always returns true in newer browsers as per the standard.\r\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\r\n    document.implementation.hasFeature('', '') !== true;\r\n}\r\n\r\n/**\r\n * Checks if an event is supported in the current execution environment.\r\n *\r\n * NOTE: This will not work correctly for non-generic events such as `change`,\r\n * `reset`, `load`, `error`, and `select`.\r\n *\r\n * Borrows from Modernizr.\r\n *\r\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\r\n * @param {?boolean} capture Check if the capture phase is supported.\r\n * @return {boolean} True if the event is supported.\r\n * @internal\r\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\r\n */\r\nfunction isEventSupported(eventNameSuffix, capture) {\r\n  if (!ExecutionEnvironment.canUseDOM ||\r\n      capture && !('addEventListener' in document)) {\r\n    return false;\r\n  }\r\n\r\n  var eventName = 'on' + eventNameSuffix;\r\n  var isSupported = eventName in document;\r\n\r\n  if (!isSupported) {\r\n    var element = document.createElement('div');\r\n    element.setAttribute(eventName, 'return;');\r\n    isSupported = typeof element[eventName] === 'function';\r\n  }\r\n\r\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\r\n    // This is the only way to test support for the `wheel` event in IE9+.\r\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\r\n  }\r\n\r\n  return isSupported;\r\n}\r\n\r\nmodule.exports = isEventSupported;\r\n", "/**\r\n * Copyright (c) 2015, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule normalizeWheel\r\n * @typechecks\r\n */\r\n\r\n'use strict';\r\n\r\nvar UserAgent_DEPRECATED = require('./UserAgent_DEPRECATED');\r\n\r\nvar isEventSupported = require('./isEventSupported');\r\n\r\n\r\n// Reasonable defaults\r\nvar PIXEL_STEP  = 10;\r\nvar LINE_HEIGHT = 40;\r\nvar PAGE_HEIGHT = 800;\r\n\r\n/**\r\n * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\r\n * complicated, thus this doc is long and (hopefully) detailed enough to answer\r\n * your questions.\r\n *\r\n * If you need to react to the mouse wheel in a predictable way, this code is\r\n * like your bestest friend. * hugs *\r\n *\r\n * As of today, there are 4 DOM event types you can listen to:\r\n *\r\n *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\r\n *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\r\n *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\r\n *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\r\n *\r\n * So what to do?  The is the best:\r\n *\r\n *   normalizeWheel.getEventType();\r\n *\r\n * In your event callback, use this code to get sane interpretation of the\r\n * deltas.  This code will return an object with properties:\r\n *\r\n *   spinX   -- normalized spin speed (use for zoom) - x plane\r\n *   spinY   -- \" - y plane\r\n *   pixelX  -- normalized distance (to pixels) - x plane\r\n *   pixelY  -- \" - y plane\r\n *\r\n * Wheel values are provided by the browser assuming you are using the wheel to\r\n * scroll a web page by a number of lines or pixels (or pages).  Values can vary\r\n * significantly on different platforms and browsers, forgetting that you can\r\n * scroll at different speeds.  Some devices (like trackpads) emit more events\r\n * at smaller increments with fine granularity, and some emit massive jumps with\r\n * linear speed or acceleration.\r\n *\r\n * This code does its best to normalize the deltas for you:\r\n *\r\n *   - spin is trying to normalize how far the wheel was spun (or trackpad\r\n *     dragged).  This is super useful for zoom support where you want to\r\n *     throw away the chunky scroll steps on the PC and make those equal to\r\n *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\r\n *     resolve a single slow step on a wheel to 1.\r\n *\r\n *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\r\n *     get the crazy differences between browsers, but at least it'll be in\r\n *     pixels!\r\n *\r\n *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\r\n *     should translate to positive value zooming IN, negative zooming OUT.\r\n *     This matches the newer 'wheel' event.\r\n *\r\n * Why are there spinX, spinY (or pixels)?\r\n *\r\n *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\r\n *     with a mouse.  It results in side-scrolling in the browser by default.\r\n *\r\n *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\r\n *\r\n *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\r\n *     probably is by browsers in conjunction with fancy 3D controllers .. but\r\n *     you know.\r\n *\r\n * Implementation info:\r\n *\r\n * Examples of 'wheel' event if you scroll slowly (down) by one step with an\r\n * average mouse:\r\n *\r\n *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\r\n *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\r\n *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\r\n *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\r\n *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\r\n *\r\n * On the trackpad:\r\n *\r\n *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\r\n *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\r\n *\r\n * On other/older browsers.. it's more complicated as there can be multiple and\r\n * also missing delta values.\r\n *\r\n * The 'wheel' event is more standard:\r\n *\r\n * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\r\n *\r\n * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\r\n * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\r\n * backward compatibility with older events.  Those other values help us\r\n * better normalize spin speed.  Example of what the browsers provide:\r\n *\r\n *                          | event.wheelDelta | event.detail\r\n *        ------------------+------------------+--------------\r\n *          Safari v5/OS X  |       -120       |       0\r\n *          Safari v5/Win7  |       -120       |       0\r\n *         Chrome v17/OS X  |       -120       |       0\r\n *         Chrome v17/Win7  |       -120       |       0\r\n *                IE9/Win7  |       -120       |   undefined\r\n *         Firefox v4/OS X  |     undefined    |       1\r\n *         Firefox v4/Win7  |     undefined    |       3\r\n *\r\n */\r\nfunction normalizeWheel(/*object*/ event) /*object*/ {\r\n  var sX = 0, sY = 0,       // spinX, spinY\r\n      pX = 0, pY = 0;       // pixelX, pixelY\r\n\r\n  // Legacy\r\n  if ('detail'      in event) { sY = event.detail; }\r\n  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }\r\n  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }\r\n  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }\r\n\r\n  // side scrolling on FF with DOMMouseScroll\r\n  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {\r\n    sX = sY;\r\n    sY = 0;\r\n  }\r\n\r\n  pX = sX * PIXEL_STEP;\r\n  pY = sY * PIXEL_STEP;\r\n\r\n  if ('deltaY' in event) { pY = event.deltaY; }\r\n  if ('deltaX' in event) { pX = event.deltaX; }\r\n\r\n  if ((pX || pY) && event.deltaMode) {\r\n    if (event.deltaMode == 1) {          // delta in LINE units\r\n      pX *= LINE_HEIGHT;\r\n      pY *= LINE_HEIGHT;\r\n    } else {                             // delta in PAGE units\r\n      pX *= PAGE_HEIGHT;\r\n      pY *= PAGE_HEIGHT;\r\n    }\r\n  }\r\n\r\n  // Fall-back if spin cannot be determined\r\n  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }\r\n  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }\r\n\r\n  return { spinX  : sX,\r\n           spinY  : sY,\r\n           pixelX : pX,\r\n           pixelY : pY };\r\n}\r\n\r\n\r\n/**\r\n * The best combination if you prefer spinX + spinY normalization.  It favors\r\n * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with\r\n * 'wheel' event, making spin speed determination impossible.\r\n */\r\nnormalizeWheel.getEventType = function() /*string*/ {\r\n  return (UserAgent_DEPRECATED.firefox())\r\n           ? 'DOMMouseScroll'\r\n           : (isEventSupported('wheel'))\r\n               ? 'wheel'\r\n               : 'mousewheel';\r\n};\r\n\r\nmodule.exports = normalizeWheel;\r\n", "module.exports = require('./src/normalizeWheel.js');\r\n", "import { __awaiter, __rest } from 'tslib';\r\nimport { jsxs, Fragment, jsx } from 'react/jsx-runtime';\r\nimport { version } from 'antd';\r\nimport AntModal from 'antd/es/modal';\r\nimport AntUpload from 'antd/es/upload';\r\nimport { compareVersions } from 'compare-versions';\r\nimport { forwardRef, useState, useRef, useCallback, useImperativeHandle, memo, useMemo } from 'react';\r\nimport AntButton from 'antd/es/button';\r\nimport AntSlider from 'antd/es/slider';\r\nimport Cropper from 'react-easy-crop';\r\n\r\nconst PREFIX = 'img-crop';\r\nconst ZOOM_INITIAL = 1;\r\nconst ZOOM_STEP = 0.1;\r\nconst ROTATION_INITIAL = 0;\r\nconst ROTATION_MIN = -180;\r\nconst ROTATION_MAX = 180;\r\nconst ROTATION_STEP = 1;\r\nconst ASPECT_MIN = 0.5;\r\nconst ASPECT_MAX = 2;\r\nconst ASPECT_STEP = 0.01;\r\n\r\nconst EasyCrop = forwardRef((props, ref) => {\r\n    const { cropperRef, zoomSlider, rotationSlider, aspectSlider, showReset, resetBtnText, modalImage, aspect: ASPECT_INITIAL, minZoom, maxZoom, cropShape, showGrid, cropperProps, } = props;\r\n    const [zoom, setZoom] = useState(ZOOM_INITIAL);\r\n    const [rotation, setRotation] = useState(ROTATION_INITIAL);\r\n    const [aspect, setAspect] = useState(ASPECT_INITIAL);\r\n    const isResetActive = zoom !== ZOOM_INITIAL ||\r\n        rotation !== ROTATION_INITIAL ||\r\n        aspect !== ASPECT_INITIAL;\r\n    const onReset = () => {\r\n        setZoom(ZOOM_INITIAL);\r\n        setRotation(ROTATION_INITIAL);\r\n        setAspect(ASPECT_INITIAL);\r\n    };\r\n    const [crop, onCropChange] = useState({ x: 0, y: 0 });\r\n    const cropPixelsRef = useRef({ width: 0, height: 0, x: 0, y: 0 });\r\n    const onCropComplete = useCallback((_, croppedAreaPixels) => {\r\n        cropPixelsRef.current = croppedAreaPixels;\r\n    }, []);\r\n    useImperativeHandle(ref, () => ({\r\n        rotation,\r\n        cropPixelsRef,\r\n        onReset,\r\n    }));\r\n    const wrapperClass = '[display:flex] [align-items:center] [width:60%] [margin-inline:auto]';\r\n    const buttonClass = '[display:flex] [align-items:center] [justify-content:center] [height:32px] [width:32px] [background:transparent] [border:0] [font-family:inherit] [font-size:18px] [cursor:pointer] disabled:[opacity:20%] disabled:[cursor:default]';\r\n    const sliderClass = '[flex:1]';\r\n    return (jsxs(Fragment, { children: [jsx(Cropper, Object.assign({}, cropperProps, { ref: cropperRef, image: modalImage, crop: crop, \r\n                //\r\n                zoom: zoom, rotation: rotation, aspect: aspect, minZoom: minZoom, maxZoom: maxZoom, zoomWithScroll: zoomSlider, \r\n                //\r\n                cropShape: cropShape, showGrid: showGrid, onCropChange: onCropChange, onZoomChange: setZoom, onRotationChange: setRotation, onCropComplete: onCropComplete, classes: {\r\n                    containerClassName: `${PREFIX}-container ![position:relative] [width:100%] [height:40vh] [&~section:first-of-type]:[margin-top:16px] [&~section:last-of-type]:[margin-bottom:16px]`,\r\n                    mediaClassName: `${PREFIX}-media`,\r\n                } })), zoomSlider && (jsxs(\"section\", { className: `${PREFIX}-control ${PREFIX}-control-zoom ${wrapperClass}`, children: [jsx(\"button\", { className: buttonClass, onClick: () => setZoom(+(zoom - ZOOM_STEP).toFixed(1)), disabled: zoom - ZOOM_STEP < minZoom, children: \"\\uFF0D\" }), jsx(AntSlider, { className: sliderClass, min: minZoom, max: maxZoom, step: ZOOM_STEP, value: zoom, onChange: setZoom }), jsx(\"button\", { className: buttonClass, onClick: () => setZoom(+(zoom + ZOOM_STEP).toFixed(1)), disabled: zoom + ZOOM_STEP > maxZoom, children: \"\\uFF0B\" })] })), rotationSlider && (jsxs(\"section\", { className: `${PREFIX}-control ${PREFIX}-control-rotation ${wrapperClass}`, children: [jsx(\"button\", { className: `${buttonClass} [font-size:16px]`, onClick: () => setRotation(rotation - ROTATION_STEP), disabled: rotation === ROTATION_MIN, children: \"\\u21BA\" }), jsx(AntSlider, { className: sliderClass, min: ROTATION_MIN, max: ROTATION_MAX, step: ROTATION_STEP, value: rotation, onChange: setRotation }), jsx(\"button\", { className: `${buttonClass} [font-size:16px]`, onClick: () => setRotation(rotation + ROTATION_STEP), disabled: rotation === ROTATION_MAX, children: \"\\u21BB\" })] })), aspectSlider && (jsxs(\"section\", { className: `${PREFIX}-control ${PREFIX}-control-aspect ${wrapperClass}`, children: [jsx(\"button\", { className: buttonClass, onClick: () => setAspect(+(aspect - ASPECT_STEP).toFixed(2)), disabled: aspect - ASPECT_STEP < ASPECT_MIN, children: \"\\u2195\\uFE0F\" }), jsx(AntSlider, { className: sliderClass, min: ASPECT_MIN, max: ASPECT_MAX, step: ASPECT_STEP, value: aspect, onChange: setAspect }), jsx(\"button\", { className: buttonClass, onClick: () => setAspect(+(aspect + ASPECT_STEP).toFixed(2)), disabled: aspect + ASPECT_STEP > ASPECT_MAX, children: \"\\u2194\\uFE0F\" })] })), showReset && (zoomSlider || rotationSlider || aspectSlider) && (jsx(AntButton, { className: \"[bottom:20px] [position:absolute]\", style: isResetActive ? {} : { opacity: 0.3, pointerEvents: 'none' }, onClick: onReset, children: resetBtnText }))] }));\r\n});\r\nvar EasyCrop$1 = memo(EasyCrop);\r\n\r\nfunction styleInject(css, ref) {\r\n  if ( ref === void 0 ) ref = {};\r\n  var insertAt = ref.insertAt;\r\n\r\n  if (typeof document === 'undefined') { return; }\r\n\r\n  var head = document.head || document.getElementsByTagName('head')[0];\r\n  var style = document.createElement('style');\r\n  style.type = 'text/css';\r\n\r\n  if (insertAt === 'top') {\r\n    if (head.firstChild) {\r\n      head.insertBefore(style, head.firstChild);\r\n    } else {\r\n      head.appendChild(style);\r\n    }\r\n  } else {\r\n    head.appendChild(style);\r\n  }\r\n\r\n  if (style.styleSheet) {\r\n    style.styleSheet.cssText = css;\r\n  } else {\r\n    style.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\n\r\nvar css_248z = \".visible{visibility:visible}.grid{display:grid}.\\\\[align-items\\\\:center\\\\]{align-items:center}.\\\\[background\\\\:transparent\\\\]{background:transparent}.\\\\[border\\\\:0\\\\]{border:0}.\\\\[bottom\\\\:20px\\\\]{bottom:20px}.\\\\[cursor\\\\:pointer\\\\]{cursor:pointer}.\\\\[display\\\\:flex\\\\]{display:flex}.\\\\[flex\\\\:1\\\\]{flex:1}.\\\\[font-family\\\\:inherit\\\\]{font-family:inherit}.\\\\[font-size\\\\:16px\\\\]{font-size:16px}.\\\\[font-size\\\\:18px\\\\]{font-size:18px}.\\\\[height\\\\:32px\\\\]{height:32px}.\\\\[height\\\\:40vh\\\\]{height:40vh}.\\\\[justify-content\\\\:center\\\\]{justify-content:center}.\\\\[margin-inline\\\\:auto\\\\]{margin-inline:auto}.\\\\[position\\\\:absolute\\\\]{position:absolute}.\\\\!\\\\[position\\\\:relative\\\\]{position:relative!important}.\\\\[width\\\\:100\\\\%\\\\]{width:100%}.\\\\[width\\\\:32px\\\\]{width:32px}.\\\\[width\\\\:60\\\\%\\\\]{width:60%}.disabled\\\\:\\\\[cursor\\\\:default\\\\]:disabled{cursor:default}.disabled\\\\:\\\\[opacity\\\\:20\\\\%\\\\]:disabled{opacity:20%}.\\\\[\\\\&\\\\~section\\\\:first-of-type\\\\]\\\\:\\\\[margin-top\\\\:16px\\\\]~section:first-of-type{margin-top:16px}.\\\\[\\\\&\\\\~section\\\\:last-of-type\\\\]\\\\:\\\\[margin-bottom\\\\:16px\\\\]~section:last-of-type{margin-bottom:16px}\";\r\nstyleInject(css_248z,{\"insertAt\":\"top\"});\r\n\r\nconst openProp = compareVersions(version, '4.23.0') === -1 ? 'visible' : 'open';\r\nconst deprecate = (obj, old, now) => {\r\n    if (old in obj) {\r\n        console.error(`\\`${old}\\` is deprecated, please use \\`${now}\\` instead`);\r\n        return obj[old];\r\n    }\r\n    return obj[now];\r\n};\r\nconst ImgCrop = forwardRef((props, cropperRef) => {\r\n    const { quality = 0.4, fillColor = 'white', \r\n    // @ts-ignore\r\n    zoomSlider: ZOOM_SLIDER = true, \r\n    // @ts-ignore\r\n    rotationSlider: ROTATION_SLIDER = false, aspectSlider = false, showReset = false, resetText, aspect = 1, minZoom = 1, maxZoom = 3, \r\n    // @ts-ignore\r\n    cropShape: CROP_SHAPE = 'rect', \r\n    // @ts-ignore\r\n    showGrid: SHOW_GRID = false, cropperProps, modalClassName, modalTitle, modalWidth, modalOk, modalCancel, onModalOk, onModalCancel, modalProps, beforeCrop, children, } = props;\r\n    /**\r\n     * init\r\n     */\r\n    const zoomSlider = deprecate(props, 'zoom', 'zoomSlider') || true;\r\n    const rotationSlider = deprecate(props, 'rotate', 'rotationSlider') || false;\r\n    const cropShape = deprecate(props, 'shape', 'cropShape') || 'rect';\r\n    const showGrid = deprecate(props, 'grid', 'showGrid') || false;\r\n    if ('onUploadFail' in props) {\r\n        console.error(`\\`onUploadFail\\` is removed, because the only way it is called, is when the file is rejected by beforeUpload`);\r\n    }\r\n    deprecate(props, 'modalMaskTransitionName', 'modalProps.maskTransitionName');\r\n    deprecate(props, 'modalTransitionName', 'modalProps.transitionName');\r\n    const cb = useRef({});\r\n    cb.current.onModalOk = onModalOk;\r\n    cb.current.onModalCancel = onModalCancel;\r\n    cb.current.beforeCrop = beforeCrop;\r\n    /**\r\n     * crop\r\n     */\r\n    const easyCropRef = useRef(null);\r\n    const getCropCanvas = useCallback((target) => {\r\n        var _a;\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        const context = ((_a = target === null || target === void 0 ? void 0 : target.getRootNode) === null || _a === void 0 ? void 0 : _a.call(target)) || document;\r\n        const imgSource = context.querySelector(`.${PREFIX}-media`);\r\n        const { width: cropWidth, height: cropHeight, x: cropX, y: cropY, } = easyCropRef.current.cropPixelsRef.current;\r\n        if (rotationSlider &&\r\n            easyCropRef.current.rotation !== ROTATION_INITIAL) {\r\n            const { naturalWidth: imgWidth, naturalHeight: imgHeight } = imgSource;\r\n            const angle = easyCropRef.current.rotation * (Math.PI / 180);\r\n            // get container for rotated image\r\n            const sine = Math.abs(Math.sin(angle));\r\n            const cosine = Math.abs(Math.cos(angle));\r\n            const squareWidth = imgWidth * cosine + imgHeight * sine;\r\n            const squareHeight = imgHeight * cosine + imgWidth * sine;\r\n            canvas.width = squareWidth;\r\n            canvas.height = squareHeight;\r\n            ctx.fillStyle = fillColor;\r\n            ctx.fillRect(0, 0, squareWidth, squareHeight);\r\n            // rotate container\r\n            const squareHalfWidth = squareWidth / 2;\r\n            const squareHalfHeight = squareHeight / 2;\r\n            ctx.translate(squareHalfWidth, squareHalfHeight);\r\n            ctx.rotate(angle);\r\n            ctx.translate(-squareHalfWidth, -squareHalfHeight);\r\n            // draw rotated image\r\n            const imgX = (squareWidth - imgWidth) / 2;\r\n            const imgY = (squareHeight - imgHeight) / 2;\r\n            ctx.drawImage(imgSource, 0, 0, imgWidth, imgHeight, imgX, imgY, imgWidth, imgHeight);\r\n            // crop rotated image\r\n            const imgData = ctx.getImageData(0, 0, squareWidth, squareHeight);\r\n            canvas.width = cropWidth;\r\n            canvas.height = cropHeight;\r\n            ctx.putImageData(imgData, -cropX, -cropY);\r\n        }\r\n        else {\r\n            canvas.width = cropWidth;\r\n            canvas.height = cropHeight;\r\n            ctx.fillStyle = fillColor;\r\n            ctx.fillRect(0, 0, cropWidth, cropHeight);\r\n            ctx.drawImage(imgSource, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);\r\n        }\r\n        return canvas;\r\n    }, [fillColor, rotationSlider]);\r\n    /**\r\n     * upload\r\n     */\r\n    const [modalImage, setModalImage] = useState('');\r\n    const onCancel = useRef();\r\n    const onOk = useRef();\r\n    const runBeforeUpload = useCallback((_a) => __awaiter(void 0, [_a], void 0, function* ({ beforeUpload, file, resolve, reject, }) {\r\n        const rawFile = file;\r\n        if (typeof beforeUpload !== 'function') {\r\n            resolve(rawFile);\r\n            return;\r\n        }\r\n        try {\r\n            // https://ant.design/components/upload-cn#api\r\n            // https://github.com/ant-design/ant-design/blob/master/components/upload/Upload.tsx#L152-L178\r\n            const result = yield beforeUpload(file, [file]);\r\n            if (result === false) {\r\n                resolve(false);\r\n            }\r\n            else {\r\n                resolve((result !== true && result) || rawFile);\r\n            }\r\n        }\r\n        catch (err) {\r\n            reject(err);\r\n        }\r\n    }), []);\r\n    const getNewBeforeUpload = useCallback((beforeUpload) => {\r\n        return ((file, fileList) => {\r\n            return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n                let processedFile = file;\r\n                if (typeof cb.current.beforeCrop === 'function') {\r\n                    try {\r\n                        const result = yield cb.current.beforeCrop(file, fileList);\r\n                        if (result === false) {\r\n                            return runBeforeUpload({ beforeUpload, file, resolve, reject }); // not open modal\r\n                        }\r\n                        if (result !== true) {\r\n                            processedFile = result || file; // will open modal\r\n                        }\r\n                    }\r\n                    catch (err) {\r\n                        return runBeforeUpload({ beforeUpload, file, resolve, reject }); // not open modal\r\n                    }\r\n                }\r\n                // read file\r\n                const reader = new FileReader();\r\n                reader.addEventListener('load', () => {\r\n                    if (typeof reader.result === 'string') {\r\n                        setModalImage(reader.result); // open modal\r\n                    }\r\n                });\r\n                reader.readAsDataURL(processedFile);\r\n                // on modal cancel\r\n                onCancel.current = () => {\r\n                    var _a, _b;\r\n                    setModalImage('');\r\n                    easyCropRef.current.onReset();\r\n                    let hasResolveCalled = false;\r\n                    (_b = (_a = cb.current).onModalCancel) === null || _b === void 0 ? void 0 : _b.call(_a, (LIST_IGNORE) => {\r\n                        resolve(LIST_IGNORE);\r\n                        hasResolveCalled = true;\r\n                    });\r\n                    if (!hasResolveCalled) {\r\n                        resolve(AntUpload.LIST_IGNORE);\r\n                    }\r\n                };\r\n                // on modal confirm\r\n                onOk.current = (event) => __awaiter(void 0, void 0, void 0, function* () {\r\n                    setModalImage('');\r\n                    easyCropRef.current.onReset();\r\n                    const canvas = getCropCanvas(event.target);\r\n                    const { type, name, uid } = processedFile;\r\n                    canvas.toBlob((blob) => __awaiter(void 0, void 0, void 0, function* () {\r\n                        const newFile = new File([blob], name, { type });\r\n                        Object.assign(newFile, { uid });\r\n                        runBeforeUpload({\r\n                            beforeUpload,\r\n                            file: newFile,\r\n                            resolve: (file) => {\r\n                                var _a, _b;\r\n                                resolve(file);\r\n                                (_b = (_a = cb.current).onModalOk) === null || _b === void 0 ? void 0 : _b.call(_a, file);\r\n                            },\r\n                            reject: (err) => {\r\n                                var _a, _b;\r\n                                reject(err);\r\n                                (_b = (_a = cb.current).onModalOk) === null || _b === void 0 ? void 0 : _b.call(_a, err);\r\n                            },\r\n                        });\r\n                    }), type, quality);\r\n                });\r\n            }));\r\n        });\r\n    }, [getCropCanvas, quality, runBeforeUpload]);\r\n    const getNewUpload = useCallback((children) => {\r\n        const upload = Array.isArray(children) ? children[0] : children;\r\n        const _a = upload.props, { beforeUpload, accept } = _a, restUploadProps = __rest(_a, [\"beforeUpload\", \"accept\"]);\r\n        return Object.assign(Object.assign({}, upload), { props: Object.assign(Object.assign({}, restUploadProps), { accept: accept || 'image/*', beforeUpload: getNewBeforeUpload(beforeUpload) }) });\r\n    }, [getNewBeforeUpload]);\r\n    /**\r\n     * modal\r\n     */\r\n    const modalBaseProps = useMemo(() => {\r\n        const obj = {};\r\n        if (modalWidth !== undefined)\r\n            obj.width = modalWidth;\r\n        if (modalOk !== undefined)\r\n            obj.okText = modalOk;\r\n        if (modalCancel !== undefined)\r\n            obj.cancelText = modalCancel;\r\n        return obj;\r\n    }, [modalCancel, modalOk, modalWidth]);\r\n    const wrapClassName = `${PREFIX}-modal${modalClassName ? ` ${modalClassName}` : ''}`;\r\n    const lang = typeof window === 'undefined' ? '' : window.navigator.language;\r\n    const isCN = lang === 'zh-CN';\r\n    const title = modalTitle || (isCN ? '编辑图片' : 'Edit image');\r\n    const resetBtnText = resetText || (isCN ? '重置' : 'Reset');\r\n    return (jsxs(Fragment, { children: [getNewUpload(children), modalImage && (jsx(AntModal, Object.assign({}, modalProps, modalBaseProps, { [openProp]: true, title: title, onCancel: onCancel.current, onOk: onOk.current, wrapClassName: wrapClassName, maskClosable: false, destroyOnClose: true, children: jsx(EasyCrop$1, { ref: easyCropRef, cropperRef: cropperRef, zoomSlider: zoomSlider, rotationSlider: rotationSlider, aspectSlider: aspectSlider, showReset: showReset, resetBtnText: resetBtnText, modalImage: modalImage, aspect: aspect, minZoom: minZoom, maxZoom: maxZoom, cropShape: cropShape, showGrid: showGrid, cropperProps: cropperProps }) })))] }));\r\n});\r\n\r\nexport { ImgCrop as default };\r\n", "/**\r\n * Allowed arithmetic operators\r\n */\r\nexport type CompareOperator = '>' | '>=' | '=' | '<' | '<=' | '!=';\r\n\r\nexport const semver =\r\n  /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\r\n\r\nexport const validateAndParse = (version: string) => {\r\n  if (typeof version !== 'string') {\r\n    throw new TypeError('Invalid argument expected string');\r\n  }\r\n  const match = version.match(semver);\r\n  if (!match) {\r\n    throw new Error(\r\n      `Invalid argument not valid semver ('${version}' received)`\r\n    );\r\n  }\r\n  match.shift();\r\n  return match;\r\n};\r\n\r\nconst isWildcard = (s: string) => s === '*' || s === 'x' || s === 'X';\r\n\r\nconst tryParse = (v: string) => {\r\n  const n = parseInt(v, 10);\r\n  return isNaN(n) ? v : n;\r\n};\r\n\r\nconst forceType = (a: string | number, b: string | number) =>\r\n  typeof a !== typeof b ? [String(a), String(b)] : [a, b];\r\n\r\nconst compareStrings = (a: string, b: string) => {\r\n  if (isWildcard(a) || isWildcard(b)) return 0;\r\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\r\n  if (ap > bp) return 1;\r\n  if (ap < bp) return -1;\r\n  return 0;\r\n};\r\n\r\nexport const compareSegments = (\r\n  a: string | string[] | RegExpMatchArray,\r\n  b: string | string[] | RegExpMatchArray\r\n) => {\r\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\r\n    const r = compareStrings(a[i] || '0', b[i] || '0');\r\n    if (r !== 0) return r;\r\n  }\r\n  return 0;\r\n};\r\n", "import { compareSegments, validateAndParse } from './utils';\r\n\r\n/**\r\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\r\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\r\n * @param v1 - First version to compare\r\n * @param v2 - Second version to compare\r\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\r\n */\r\nexport const compareVersions = (v1: string, v2: string) => {\r\n  // validate input and split into segments\r\n  const n1 = validateAndParse(v1);\r\n  const n2 = validateAndParse(v2);\r\n\r\n  // pop off the patch\r\n  const p1 = n1.pop();\r\n  const p2 = n2.pop();\r\n\r\n  // validate numbers\r\n  const r = compareSegments(n1, n2);\r\n  if (r !== 0) return r;\r\n\r\n  // validate pre-release\r\n  if (p1 && p2) {\r\n    return compareSegments(p1.split('.'), p2.split('.'));\r\n  } else if (p1 || p2) {\r\n    return p1 ? -1 : 1;\r\n  }\r\n\r\n  return 0;\r\n};\r\n", "import { compareVersions } from './compareVersions';\r\nimport { CompareOperator } from './utils';\r\n\r\n/**\r\n * Compare [semver](https://semver.org/) version strings using the specified operator.\r\n *\r\n * @param v1 First version to compare\r\n * @param v2 Second version to compare\r\n * @param operator Allowed arithmetic operator to use\r\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\r\n *\r\n * @example\r\n * ```\r\n * compare('10.1.8', '10.0.4', '>'); // return true\r\n * compare('10.0.1', '10.0.1', '='); // return true\r\n * compare('10.1.1', '10.2.2', '<'); // return true\r\n * compare('10.1.1', '10.2.2', '<='); // return true\r\n * compare('10.1.1', '10.2.2', '>='); // return false\r\n * ```\r\n */\r\nexport const compare = (v1: string, v2: string, operator: CompareOperator) => {\r\n  // validate input operator\r\n  assertValidOperator(operator);\r\n\r\n  // since result of compareVersions can only be -1 or 0 or 1\r\n  // a simple map can be used to replace switch\r\n  const res = compareVersions(v1, v2);\r\n\r\n  return operatorResMap[operator].includes(res);\r\n};\r\n\r\nconst operatorResMap = {\r\n  '>': [1],\r\n  '>=': [0, 1],\r\n  '=': [0],\r\n  '<=': [-1, 0],\r\n  '<': [-1],\r\n  '!=': [-1, 1],\r\n};\r\n\r\nconst allowedOperators = Object.keys(operatorResMap);\r\n\r\nconst assertValidOperator = (op: string) => {\r\n  if (typeof op !== 'string') {\r\n    throw new TypeError(\r\n      `Invalid operator type, expected string but got ${typeof op}`\r\n    );\r\n  }\r\n  if (allowedOperators.indexOf(op) === -1) {\r\n    throw new Error(\r\n      `Invalid operator, expected one of ${allowedOperators.join('|')}`\r\n    );\r\n  }\r\n};\r\n", "import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = rotateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Compute media zoom.\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\n */\nexport function getMediaZoom(mediaSize: MediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height\n    ? mediaSize.width / mediaSize.naturalWidth\n    : mediaSize.height / mediaSize.naturalHeight\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n\n  return clamp(position, -maxPosition, maxPosition)\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition ? limitArea : noOp\n\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  // calculate the crop area in percentages\n  // in the rotated space\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width) *\n        100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) /\n        mediaBBoxSize.height) *\n        100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaBBoxSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaBBoxSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.width,\n      (croppedAreaPercentages.width * mediaNaturalBBoxSize.width) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.height,\n      (croppedAreaPercentages.height * mediaNaturalBBoxSize.height) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.width - sizePixels.width,\n        (croppedAreaPercentages.x * mediaNaturalBBoxSize.width) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.height - sizePixels.height,\n        (croppedAreaPercentages.y * mediaNaturalBBoxSize.height) / 100\n      )\n    ),\n  }\n\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPercentages.\n */\nexport function getInitialCropFromCroppedAreaPercentages(\n  croppedAreaPercentages: Area,\n  mediaSize: MediaSize,\n  rotation: number,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n) {\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  // This is the inverse process of computeCroppedArea\n  const zoom = clamp(\n    (cropSize.width / mediaBBoxSize.width) * (100 / croppedAreaPercentages.width),\n    minZoom,\n    maxZoom\n  )\n\n  const crop = {\n    x:\n      (zoom * mediaBBoxSize.width) / 2 -\n      cropSize.width / 2 -\n      mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y:\n      (zoom * mediaBBoxSize.height) / 2 -\n      cropSize.height / 2 -\n      mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100),\n  }\n\n  return { crop, zoom }\n}\n\n/**\n * Compute zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize: Size\n): number {\n  const mediaZoom = getMediaZoom(mediaSize)\n\n  return cropSize.height > cropSize.width\n    ? cropSize.height / (croppedAreaPixels.height * mediaZoom)\n    : cropSize.width / (croppedAreaPixels.width * mediaZoom)\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  rotation = 0,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n): { crop: Point; zoom: number } {\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  const zoom = clamp(\n    getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize),\n    minZoom,\n    maxZoom\n  )\n\n  const cropZoom =\n    cropSize.height > cropSize.width\n      ? cropSize.height / croppedAreaPixels.height\n      : cropSize.width / croppedAreaPixels.width\n\n  const crop = {\n    x:\n      ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y:\n      ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) *\n      cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\nexport function getRadianAngle(degreeValue: number) {\n  return (degreeValue * Math.PI) / 180\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function rotateSize(width: number, height: number, rotation: number): Size {\n  const rotRad = getRadianAngle(rotation)\n\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\n  }\n}\n\n/**\n * Clamp value between min and max\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter((value) => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n", "import * as React from 'react'\nimport normalizeWheel from 'normalize-wheel'\nimport { Area, MediaSize, Point, Size, VideoSrc } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  getInitialCropFromCroppedAreaPercentages,\n  classNames,\n  clamp,\n} from './helpers'\nimport cssStyles from './styles.css'\n\nexport type CropperProps = {\n  image?: string\n  video?: string | VideoSrc[]\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  objectFit?: 'contain' | 'cover' | 'horizontal-cover' | 'vertical-cover'\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n  initialCroppedAreaPixels?: Area\n  initialCroppedAreaPercentages?: Area\n  onTouchRequest?: (e: React.TouchEvent<HTMLDivElement>) => boolean\n  onWheelRequest?: (e: WheelEvent) => boolean\n  setImageRef?: (ref: React.RefObject<HTMLImageElement>) => void\n  setVideoRef?: (ref: React.RefObject<HTMLVideoElement>) => void\n  setMediaSize?: (size: MediaSize) => void\n  setCropSize?: (size: Size) => void\n  nonce?: string\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n  mediaObjectFit: String | undefined\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\ntype GestureEvent = UIEvent & {\n  rotation: number\n  scale: number\n  clientX: number\n  clientY: number\n}\n\nclass Cropper extends React.Component<CropperProps, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect' as const,\n    objectFit: 'contain' as const,\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: React.RefObject<HTMLImageElement> = React.createRef()\n  videoRef: React.RefObject<HTMLVideoElement> = React.createRef()\n  containerPosition: Point = { x: 0, y: 0 }\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  gestureZoomStart = 0\n  gestureRotationStart = 0\n  isTouching = false\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n  currentDoc: Document | null = typeof document !== 'undefined' ? document : null\n  currentWindow: Window | null = typeof window !== 'undefined' ? window : null\n  resizeObserver: ResizeObserver | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n    mediaObjectFit: undefined,\n  }\n\n  componentDidMount() {\n    if (!this.currentDoc || !this.currentWindow) return\n    if (this.containerRef) {\n      if (this.containerRef.ownerDocument) {\n        this.currentDoc = this.containerRef.ownerDocument\n      }\n      if (this.currentDoc.defaultView) {\n        this.currentWindow = this.currentDoc.defaultView\n      }\n\n      this.initResizeObserver()\n      // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant\n      if (typeof window.ResizeObserver === 'undefined') {\n        this.currentWindow.addEventListener('resize', this.computeSizes)\n      }\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.onGestureStart as EventListener)\n    }\n\n    this.currentDoc.addEventListener('scroll', this.onScroll)\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = this.currentDoc.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      if (this.props.nonce) {\n        this.styleRef.setAttribute('nonce', this.props.nonce)\n      }\n      this.styleRef.innerHTML = cssStyles\n      this.currentDoc.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef.current && this.imageRef.current.complete) {\n      this.onMediaLoad()\n    }\n\n    // set image and video refs in the parent if the callbacks exist\n    if (this.props.setImageRef) {\n      this.props.setImageRef(this.imageRef)\n    }\n\n    if (this.props.setVideoRef) {\n      this.props.setVideoRef(this.videoRef)\n    }\n  }\n\n  componentWillUnmount() {\n    if (!this.currentDoc || !this.currentWindow) return\n    if (typeof window.ResizeObserver === 'undefined') {\n      this.currentWindow.removeEventListener('resize', this.computeSizes)\n    }\n    this.resizeObserver?.disconnect()\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.parentNode?.removeChild(this.styleRef)\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: CropperProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.objectFit !== this.props.objectFit) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    } else if (\n      prevProps.crop?.x !== this.props.crop?.x ||\n      prevProps.crop?.y !== this.props.crop?.y\n    ) {\n      this.emitCropAreaChange()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n    if (prevProps.video !== this.props.video) {\n      this.videoRef.current?.load()\n    }\n\n    const objectFit = this.getObjectFit()\n    if (objectFit !== this.state.mediaObjectFit) {\n      this.setState({ mediaObjectFit: objectFit }, this.computeSizes)\n    }\n  }\n\n  initResizeObserver = () => {\n    if (typeof window.ResizeObserver === 'undefined' || !this.containerRef) {\n      return\n    }\n    let isFirstResize = true\n    this.resizeObserver = new window.ResizeObserver((entries) => {\n      if (isFirstResize) {\n        isFirstResize = false // observe() is called on mount, we don't want to trigger a recompute on mount\n        return\n      }\n      this.computeSizes()\n    })\n    this.resizeObserver.observe(this.containerRef)\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    if (!this.currentDoc) return\n    this.currentDoc.removeEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.removeEventListener('mouseup', this.onDragStopped)\n    this.currentDoc.removeEventListener('touchmove', this.onTouchMove)\n    this.currentDoc.removeEventListener('touchend', this.onDragStopped)\n    this.currentDoc.removeEventListener('gesturemove', this.onGestureMove as EventListener)\n    this.currentDoc.removeEventListener('gestureend', this.onGestureEnd as EventListener)\n    this.currentDoc.removeEventListener('scroll', this.onScroll)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    const cropSize = this.computeSizes()\n\n    if (cropSize) {\n      this.emitCropData()\n      this.setInitialCrop(cropSize)\n    }\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = (cropSize: Size) => {\n    if (this.props.initialCroppedAreaPercentages) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPercentages(\n        this.props.initialCroppedAreaPercentages,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    } else if (this.props.initialCroppedAreaPixels) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n        this.props.initialCroppedAreaPixels,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    }\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  getObjectFit() {\n    if (this.props.objectFit === 'cover') {\n      const mediaRef = this.imageRef.current || this.videoRef.current\n\n      if (mediaRef && this.containerRef) {\n        this.containerRect = this.containerRef.getBoundingClientRect()\n        const containerAspect = this.containerRect.width / this.containerRect.height\n        const naturalWidth =\n          this.imageRef.current?.naturalWidth || this.videoRef.current?.videoWidth || 0\n        const naturalHeight =\n          this.imageRef.current?.naturalHeight || this.videoRef.current?.videoHeight || 0\n        const mediaAspect = naturalWidth / naturalHeight\n\n        return mediaAspect < containerAspect ? 'horizontal-cover' : 'vertical-cover'\n      }\n      return 'horizontal-cover'\n    }\n\n    return this.props.objectFit\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef.current || this.videoRef.current\n\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n      this.saveContainerPosition()\n      const containerAspect = this.containerRect.width / this.containerRect.height\n      const naturalWidth =\n        this.imageRef.current?.naturalWidth || this.videoRef.current?.videoWidth || 0\n      const naturalHeight =\n        this.imageRef.current?.naturalHeight || this.videoRef.current?.videoHeight || 0\n      const isMediaScaledDown =\n        mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight\n      const mediaAspect = naturalWidth / naturalHeight\n\n      // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n      // as the values they report are rounded. That will result in precision losses\n      // when calculating zoom. We use the fact that the media is positionned relative\n      // to the container. That allows us to use the container's dimensions\n      // and natural aspect ratio of the media to calculate accurate media size.\n      // However, for this to work, the container should not be rotated\n      let renderedMediaSize: Size\n\n      if (isMediaScaledDown) {\n        switch (this.state.mediaObjectFit) {\n          default:\n          case 'contain':\n            renderedMediaSize =\n              containerAspect > mediaAspect\n                ? {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n                : {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n            break\n          case 'horizontal-cover':\n            renderedMediaSize = {\n              width: this.containerRect.width,\n              height: this.containerRect.width / mediaAspect,\n            }\n            break\n          case 'vertical-cover':\n            renderedMediaSize = {\n              width: this.containerRect.height * mediaAspect,\n              height: this.containerRect.height,\n            }\n            break\n        }\n      } else {\n        renderedMediaSize = {\n          width: mediaRef.offsetWidth,\n          height: mediaRef.offsetHeight,\n        }\n      }\n\n      this.mediaSize = {\n        ...renderedMediaSize,\n        naturalWidth,\n        naturalHeight,\n      }\n\n      // set media size in the parent\n      if (this.props.setMediaSize) {\n        this.props.setMediaSize(this.mediaSize)\n      }\n\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            this.mediaSize.width,\n            this.mediaSize.height,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n      this.setState({ cropSize }, this.recomputeCropPosition)\n      // pass crop size to parent\n      if (this.props.setCropSize) {\n        this.props.setCropSize(cropSize)\n      }\n\n      return cropSize\n    }\n  }\n\n  saveContainerPosition = () => {\n    if (this.containerRef) {\n      const bounds = this.containerRef.getBoundingClientRect()\n      this.containerPosition = { x: bounds.left, y: bounds.top }\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent | GestureEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.currentDoc.addEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.addEventListener('mouseup', this.onDragStopped)\n    this.saveContainerPosition()\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onScroll = (e: Event) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.saveContainerPosition()\n  }\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    if (!this.currentDoc) return\n    this.isTouching = true\n    if (this.props.onTouchRequest && !this.props.onTouchRequest(e)) {\n      return\n    }\n\n    this.currentDoc.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    this.currentDoc.addEventListener('touchend', this.onDragStopped)\n\n    this.saveContainerPosition()\n\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onGestureStart = (e: GestureEvent) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.currentDoc.addEventListener('gesturechange', this.onGestureMove as EventListener)\n    this.currentDoc.addEventListener('gestureend', this.onGestureEnd as EventListener)\n    this.gestureZoomStart = this.props.zoom\n    this.gestureRotationStart = this.props.rotation\n  }\n\n  onGestureMove = (e: GestureEvent) => {\n    e.preventDefault()\n    if (this.isTouching) {\n      // this is to avoid conflict between gesture and touch events\n      return\n    }\n\n    const point = Cropper.getMousePoint(e)\n    const newZoom = this.gestureZoomStart - 1 + e.scale\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n    if (this.props.onRotationChange) {\n      const newRotation = this.gestureRotationStart + e.rotation\n      this.props.onRotationChange(newRotation)\n    }\n  }\n\n  onGestureEnd = (e: GestureEvent) => {\n    this.cleanEvents()\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (!this.currentWindow) return\n    if (this.rafDragTimeout) this.currentWindow.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = this.currentWindow.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.isTouching = false\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    if (!this.currentDoc || !this.currentWindow) return\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center, { shouldUpdatePosition: false })\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    if (!this.currentWindow) return\n    if (this.props.onWheelRequest && !this.props.onWheelRequest(e)) {\n      return\n    }\n\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const { pixelY } = normalizeWheel(e)\n    const newZoom = this.props.zoom - (pixelY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = this.currentWindow.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point, containerTopLeft: Point): Point => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - containerTopLeft.x),\n      y: this.containerRect.height / 2 - (y - containerTopLeft.y),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point, { shouldUpdatePosition = true } = {}) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const newZoom = clamp(zoom, this.props.minZoom, this.props.maxZoom)\n\n    if (shouldUpdatePosition) {\n      const zoomPoint = this.getPointOnContainer(point, this.containerPosition)\n      const zoomTarget = this.getPointOnMedia(zoomPoint)\n      const requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            newZoom,\n            this.props.rotation\n          )\n        : requestedPosition\n\n      this.props.onCropChange(newPosition)\n    }\n    this.props.onZoomChange(newZoom)\n  }\n\n  getCropData = () => {\n    if (!this.state.cropSize) {\n      return null\n    }\n\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    return computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n  }\n\n  emitCropData = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropComplete) {\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n    }\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  emitCropAreaChange = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n    } = this.props\n\n    const objectFit = this.state.mediaObjectFit ?? this.getObjectFit()\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={(el) => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames(\n              'reactEasyCrop_Image',\n              objectFit === 'contain' && 'reactEasyCrop_Contain',\n              objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n              objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n              mediaClassName\n            )}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={this.imageRef}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              playsInline\n              loop\n              muted={true}\n              className={classNames(\n                'reactEasyCrop_Video',\n                objectFit === 'contain' && 'reactEasyCrop_Contain',\n                objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n                objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n                mediaClassName\n              )}\n              {...mediaProps}\n              ref={this.videoRef}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            >\n              {(Array.isArray(video) ? video : [{ src: video }]).map((item) => (\n                <source key={item.src} {...item} />\n              ))}\n            </video>\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"],
=======
  "sourcesContent": ["/**\n * Copyright 2004-present Facebook. All Rights Reserved.\n *\n * @providesModule UserAgent_DEPRECATED\n */\n\n/**\n *  Provides entirely client-side User Agent and OS detection. You should prefer\n *  the non-deprecated UserAgent module when possible, which exposes our\n *  authoritative server-side PHP-based detection to the client.\n *\n *  Usage is straightforward:\n *\n *    if (UserAgent_DEPRECATED.ie()) {\n *      //  IE\n *    }\n *\n *  You can also do version checks:\n *\n *    if (UserAgent_DEPRECATED.ie() >= 7) {\n *      //  IE7 or better\n *    }\n *\n *  The browser functions will return NaN if the browser does not match, so\n *  you can also do version compares the other way:\n *\n *    if (UserAgent_DEPRECATED.ie() < 7) {\n *      //  IE6 or worse\n *    }\n *\n *  Note that the version is a float and may include a minor version number,\n *  so you should always use range operators to perform comparisons, not\n *  strict equality.\n *\n *  **Note:** You should **strongly** prefer capability detection to browser\n *  version detection where it's reasonable:\n *\n *    http://www.quirksmode.org/js/support.html\n *\n *  Further, we have a large number of mature wrapper functions and classes\n *  which abstract away many browser irregularities. Check the documentation,\n *  grep for things, or ask on javascript@lists.facebook.com before writing yet\n *  another copy of \"event || window.event\".\n *\n */\n\nvar _populated = false;\n\n// Browsers\nvar _ie, _firefox, _opera, _webkit, _chrome;\n\n// Actual IE browser for compatibility mode\nvar _ie_real_version;\n\n// Platforms\nvar _osx, _windows, _linux, _android;\n\n// Architectures\nvar _win64;\n\n// Devices\nvar _iphone, _ipad, _native;\n\nvar _mobile;\n\nfunction _populate() {\n  if (_populated) {\n    return;\n  }\n\n  _populated = true;\n\n  // To work around buggy JS libraries that can't handle multi-digit\n  // version numbers, Opera 10's user agent string claims it's Opera\n  // 9, then later includes a Version/X.Y field:\n  //\n  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10\n  var uas = navigator.userAgent;\n  var agent = /(?:MSIE.(\\d+\\.\\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\\d+\\.\\d+))|(?:Opera(?:.+Version.|.)(\\d+\\.\\d+))|(?:AppleWebKit.(\\d+(?:\\.\\d+)?))|(?:Trident\\/\\d+\\.\\d+.*rv:(\\d+\\.\\d+))/.exec(uas);\n  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);\n\n  _iphone = /\\b(iPhone|iP[ao]d)/.exec(uas);\n  _ipad = /\\b(iP[ao]d)/.exec(uas);\n  _android = /Android/i.exec(uas);\n  _native = /FBAN\\/\\w+;/i.exec(uas);\n  _mobile = /Mobile/i.exec(uas);\n\n  // Note that the IE team blog would have you believe you should be checking\n  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming\n  // from either x64 or ia64;  so ultimately, you should just check for Win64\n  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit\n  // Windows will send 'WOW64' instead.\n  _win64 = !!(/Win64/.exec(uas));\n\n  if (agent) {\n    _ie = agent[1] ? parseFloat(agent[1]) : (\n          agent[5] ? parseFloat(agent[5]) : NaN);\n    // IE compatibility mode\n    if (_ie && document && document.documentMode) {\n      _ie = document.documentMode;\n    }\n    // grab the \"true\" ie version from the trident token if available\n    var trident = /(?:Trident\\/(\\d+.\\d+))/.exec(uas);\n    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;\n\n    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;\n    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;\n    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;\n    if (_webkit) {\n      // We do not add the regexp to the above test, because it will always\n      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in\n      // the userAgent string.\n      agent = /(?:Chrome\\/(\\d+\\.\\d+))/.exec(uas);\n      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;\n    } else {\n      _chrome = NaN;\n    }\n  } else {\n    _ie = _firefox = _opera = _chrome = _webkit = NaN;\n  }\n\n  if (os) {\n    if (os[1]) {\n      // Detect OS X version.  If no version number matches, set _osx to true.\n      // Version examples:  10, 10_6_1, 10.7\n      // Parses version number as a float, taking only first two sets of\n      // digits.  If only one set of digits is found, returns just the major\n      // version number.\n      var ver = /(?:Mac OS X (\\d+(?:[._]\\d+)?))/.exec(uas);\n\n      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;\n    } else {\n      _osx = false;\n    }\n    _windows = !!os[2];\n    _linux   = !!os[3];\n  } else {\n    _osx = _windows = _linux = false;\n  }\n}\n\nvar UserAgent_DEPRECATED = {\n\n  /**\n   *  Check if the UA is Internet Explorer.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  ie: function() {\n    return _populate() || _ie;\n  },\n\n  /**\n   * Check if we're in Internet Explorer compatibility mode.\n   *\n   * @return bool true if in compatibility mode, false if\n   * not compatibility mode or not ie\n   */\n  ieCompatibilityMode: function() {\n    return _populate() || (_ie_real_version > _ie);\n  },\n\n\n  /**\n   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we\n   * only need this because Skype can't handle 64-bit IE yet.  We need to remove\n   * this when we don't need it -- tracked by #601957.\n   */\n  ie64: function() {\n    return UserAgent_DEPRECATED.ie() && _win64;\n  },\n\n  /**\n   *  Check if the UA is Firefox.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  firefox: function() {\n    return _populate() || _firefox;\n  },\n\n\n  /**\n   *  Check if the UA is Opera.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  opera: function() {\n    return _populate() || _opera;\n  },\n\n\n  /**\n   *  Check if the UA is WebKit.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  webkit: function() {\n    return _populate() || _webkit;\n  },\n\n  /**\n   *  For Push\n   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit\n   */\n  safari: function() {\n    return UserAgent_DEPRECATED.webkit();\n  },\n\n  /**\n   *  Check if the UA is a Chrome browser.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  chrome : function() {\n    return _populate() || _chrome;\n  },\n\n\n  /**\n   *  Check if the user is running Windows.\n   *\n   *  @return bool `true' if the user's OS is Windows.\n   */\n  windows: function() {\n    return _populate() || _windows;\n  },\n\n\n  /**\n   *  Check if the user is running Mac OS X.\n   *\n   *  @return float|bool   Returns a float if a version number is detected,\n   *                       otherwise true/false.\n   */\n  osx: function() {\n    return _populate() || _osx;\n  },\n\n  /**\n   * Check if the user is running Linux.\n   *\n   * @return bool `true' if the user's OS is some flavor of Linux.\n   */\n  linux: function() {\n    return _populate() || _linux;\n  },\n\n  /**\n   * Check if the user is running on an iPhone or iPod platform.\n   *\n   * @return bool `true' if the user is running some flavor of the\n   *    iPhone OS.\n   */\n  iphone: function() {\n    return _populate() || _iphone;\n  },\n\n  mobile: function() {\n    return _populate() || (_iphone || _ipad || _android || _mobile);\n  },\n\n  nativeApp: function() {\n    // webviews inside of the native apps\n    return _populate() || _native;\n  },\n\n  android: function() {\n    return _populate() || _android;\n  },\n\n  ipad: function() {\n    return _populate() || _ipad;\n  }\n};\n\nmodule.exports = UserAgent_DEPRECATED;\n", "/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n/*jslint evil: true */\n\n'use strict';\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n", "/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isEventSupported\n */\n\n'use strict';\n\nvar ExecutionEnvironment = require('./ExecutionEnvironment');\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature =\n    document.implementation &&\n    document.implementation.hasFeature &&\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM ||\n      capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n", "/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule normalizeWheel\n * @typechecks\n */\n\n'use strict';\n\nvar UserAgent_DEPRECATED = require('./UserAgent_DEPRECATED');\n\nvar isEventSupported = require('./isEventSupported');\n\n\n// Reasonable defaults\nvar PIXEL_STEP  = 10;\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\n\n/**\n * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\n * complicated, thus this doc is long and (hopefully) detailed enough to answer\n * your questions.\n *\n * If you need to react to the mouse wheel in a predictable way, this code is\n * like your bestest friend. * hugs *\n *\n * As of today, there are 4 DOM event types you can listen to:\n *\n *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\n *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\n *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\n *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\n *\n * So what to do?  The is the best:\n *\n *   normalizeWheel.getEventType();\n *\n * In your event callback, use this code to get sane interpretation of the\n * deltas.  This code will return an object with properties:\n *\n *   spinX   -- normalized spin speed (use for zoom) - x plane\n *   spinY   -- \" - y plane\n *   pixelX  -- normalized distance (to pixels) - x plane\n *   pixelY  -- \" - y plane\n *\n * Wheel values are provided by the browser assuming you are using the wheel to\n * scroll a web page by a number of lines or pixels (or pages).  Values can vary\n * significantly on different platforms and browsers, forgetting that you can\n * scroll at different speeds.  Some devices (like trackpads) emit more events\n * at smaller increments with fine granularity, and some emit massive jumps with\n * linear speed or acceleration.\n *\n * This code does its best to normalize the deltas for you:\n *\n *   - spin is trying to normalize how far the wheel was spun (or trackpad\n *     dragged).  This is super useful for zoom support where you want to\n *     throw away the chunky scroll steps on the PC and make those equal to\n *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\n *     resolve a single slow step on a wheel to 1.\n *\n *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\n *     get the crazy differences between browsers, but at least it'll be in\n *     pixels!\n *\n *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\n *     should translate to positive value zooming IN, negative zooming OUT.\n *     This matches the newer 'wheel' event.\n *\n * Why are there spinX, spinY (or pixels)?\n *\n *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\n *     with a mouse.  It results in side-scrolling in the browser by default.\n *\n *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\n *\n *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\n *     probably is by browsers in conjunction with fancy 3D controllers .. but\n *     you know.\n *\n * Implementation info:\n *\n * Examples of 'wheel' event if you scroll slowly (down) by one step with an\n * average mouse:\n *\n *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\n *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\n *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\n *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\n *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\n *\n * On the trackpad:\n *\n *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\n *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\n *\n * On other/older browsers.. it's more complicated as there can be multiple and\n * also missing delta values.\n *\n * The 'wheel' event is more standard:\n *\n * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n *\n * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\n * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\n * backward compatibility with older events.  Those other values help us\n * better normalize spin speed.  Example of what the browsers provide:\n *\n *                          | event.wheelDelta | event.detail\n *        ------------------+------------------+--------------\n *          Safari v5/OS X  |       -120       |       0\n *          Safari v5/Win7  |       -120       |       0\n *         Chrome v17/OS X  |       -120       |       0\n *         Chrome v17/Win7  |       -120       |       0\n *                IE9/Win7  |       -120       |   undefined\n *         Firefox v4/OS X  |     undefined    |       1\n *         Firefox v4/Win7  |     undefined    |       3\n *\n */\nfunction normalizeWheel(/*object*/ event) /*object*/ {\n  var sX = 0, sY = 0,       // spinX, spinY\n      pX = 0, pY = 0;       // pixelX, pixelY\n\n  // Legacy\n  if ('detail'      in event) { sY = event.detail; }\n  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }\n  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }\n  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }\n\n  // side scrolling on FF with DOMMouseScroll\n  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {\n    sX = sY;\n    sY = 0;\n  }\n\n  pX = sX * PIXEL_STEP;\n  pY = sY * PIXEL_STEP;\n\n  if ('deltaY' in event) { pY = event.deltaY; }\n  if ('deltaX' in event) { pX = event.deltaX; }\n\n  if ((pX || pY) && event.deltaMode) {\n    if (event.deltaMode == 1) {          // delta in LINE units\n      pX *= LINE_HEIGHT;\n      pY *= LINE_HEIGHT;\n    } else {                             // delta in PAGE units\n      pX *= PAGE_HEIGHT;\n      pY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }\n  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }\n\n  return { spinX  : sX,\n           spinY  : sY,\n           pixelX : pX,\n           pixelY : pY };\n}\n\n\n/**\n * The best combination if you prefer spinX + spinY normalization.  It favors\n * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with\n * 'wheel' event, making spin speed determination impossible.\n */\nnormalizeWheel.getEventType = function() /*string*/ {\n  return (UserAgent_DEPRECATED.firefox())\n           ? 'DOMMouseScroll'\n           : (isEventSupported('wheel'))\n               ? 'wheel'\n               : 'mousewheel';\n};\n\nmodule.exports = normalizeWheel;\n", "module.exports = require('./src/normalizeWheel.js');\n", "import { __awaiter, __rest } from 'tslib';\nimport { jsxs, Fragment, jsx } from 'react/jsx-runtime';\nimport { version } from 'antd';\nimport AntModal from 'antd/es/modal';\nimport AntUpload from 'antd/es/upload';\nimport { compareVersions } from 'compare-versions';\nimport { forwardRef, useState, useRef, useCallback, useImperativeHandle, memo, useMemo } from 'react';\nimport AntButton from 'antd/es/button';\nimport AntSlider from 'antd/es/slider';\nimport Cropper from 'react-easy-crop';\n\nconst PREFIX = 'img-crop';\nconst ZOOM_INITIAL = 1;\nconst ZOOM_STEP = 0.1;\nconst ROTATION_INITIAL = 0;\nconst ROTATION_MIN = -180;\nconst ROTATION_MAX = 180;\nconst ROTATION_STEP = 1;\nconst ASPECT_MIN = 0.5;\nconst ASPECT_MAX = 2;\nconst ASPECT_STEP = 0.01;\n\nconst EasyCrop = forwardRef((props, ref) => {\n    const { cropperRef, zoomSlider, rotationSlider, aspectSlider, showReset, resetBtnText, modalImage, aspect: ASPECT_INITIAL, minZoom, maxZoom, cropShape, showGrid, cropperProps, } = props;\n    const [zoom, setZoom] = useState(ZOOM_INITIAL);\n    const [rotation, setRotation] = useState(ROTATION_INITIAL);\n    const [aspect, setAspect] = useState(ASPECT_INITIAL);\n    const isResetActive = zoom !== ZOOM_INITIAL ||\n        rotation !== ROTATION_INITIAL ||\n        aspect !== ASPECT_INITIAL;\n    const onReset = () => {\n        setZoom(ZOOM_INITIAL);\n        setRotation(ROTATION_INITIAL);\n        setAspect(ASPECT_INITIAL);\n    };\n    const [crop, onCropChange] = useState({ x: 0, y: 0 });\n    const cropPixelsRef = useRef({ width: 0, height: 0, x: 0, y: 0 });\n    const onCropComplete = useCallback((_, croppedAreaPixels) => {\n        cropPixelsRef.current = croppedAreaPixels;\n    }, []);\n    useImperativeHandle(ref, () => ({\n        rotation,\n        cropPixelsRef,\n        onReset,\n    }));\n    const wrapperClass = '[display:flex] [align-items:center] [width:60%] [margin-inline:auto]';\n    const buttonClass = '[display:flex] [align-items:center] [justify-content:center] [height:32px] [width:32px] [background:transparent] [border:0] [font-family:inherit] [font-size:18px] [cursor:pointer] disabled:[opacity:20%] disabled:[cursor:default]';\n    const sliderClass = '[flex:1]';\n    return (jsxs(Fragment, { children: [jsx(Cropper, Object.assign({}, cropperProps, { ref: cropperRef, image: modalImage, crop: crop, \n                //\n                zoom: zoom, rotation: rotation, aspect: aspect, minZoom: minZoom, maxZoom: maxZoom, zoomWithScroll: zoomSlider, \n                //\n                cropShape: cropShape, showGrid: showGrid, onCropChange: onCropChange, onZoomChange: setZoom, onRotationChange: setRotation, onCropComplete: onCropComplete, classes: {\n                    containerClassName: `${PREFIX}-container ![position:relative] [width:100%] [height:40vh] [&~section:first-of-type]:[margin-top:16px] [&~section:last-of-type]:[margin-bottom:16px]`,\n                    mediaClassName: `${PREFIX}-media`,\n                } })), zoomSlider && (jsxs(\"section\", { className: `${PREFIX}-control ${PREFIX}-control-zoom ${wrapperClass}`, children: [jsx(\"button\", { className: buttonClass, onClick: () => setZoom(+(zoom - ZOOM_STEP).toFixed(1)), disabled: zoom - ZOOM_STEP < minZoom, children: \"\\uFF0D\" }), jsx(AntSlider, { className: sliderClass, min: minZoom, max: maxZoom, step: ZOOM_STEP, value: zoom, onChange: setZoom }), jsx(\"button\", { className: buttonClass, onClick: () => setZoom(+(zoom + ZOOM_STEP).toFixed(1)), disabled: zoom + ZOOM_STEP > maxZoom, children: \"\\uFF0B\" })] })), rotationSlider && (jsxs(\"section\", { className: `${PREFIX}-control ${PREFIX}-control-rotation ${wrapperClass}`, children: [jsx(\"button\", { className: `${buttonClass} [font-size:16px]`, onClick: () => setRotation(rotation - ROTATION_STEP), disabled: rotation === ROTATION_MIN, children: \"\\u21BA\" }), jsx(AntSlider, { className: sliderClass, min: ROTATION_MIN, max: ROTATION_MAX, step: ROTATION_STEP, value: rotation, onChange: setRotation }), jsx(\"button\", { className: `${buttonClass} [font-size:16px]`, onClick: () => setRotation(rotation + ROTATION_STEP), disabled: rotation === ROTATION_MAX, children: \"\\u21BB\" })] })), aspectSlider && (jsxs(\"section\", { className: `${PREFIX}-control ${PREFIX}-control-aspect ${wrapperClass}`, children: [jsx(\"button\", { className: buttonClass, onClick: () => setAspect(+(aspect - ASPECT_STEP).toFixed(2)), disabled: aspect - ASPECT_STEP < ASPECT_MIN, children: \"\\u2195\\uFE0F\" }), jsx(AntSlider, { className: sliderClass, min: ASPECT_MIN, max: ASPECT_MAX, step: ASPECT_STEP, value: aspect, onChange: setAspect }), jsx(\"button\", { className: buttonClass, onClick: () => setAspect(+(aspect + ASPECT_STEP).toFixed(2)), disabled: aspect + ASPECT_STEP > ASPECT_MAX, children: \"\\u2194\\uFE0F\" })] })), showReset && (zoomSlider || rotationSlider || aspectSlider) && (jsx(AntButton, { className: \"[bottom:20px] [position:absolute]\", style: isResetActive ? {} : { opacity: 0.3, pointerEvents: 'none' }, onClick: onReset, children: resetBtnText }))] }));\n});\nvar EasyCrop$1 = memo(EasyCrop);\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".visible{visibility:visible}.grid{display:grid}.\\\\[align-items\\\\:center\\\\]{align-items:center}.\\\\[background\\\\:transparent\\\\]{background:transparent}.\\\\[border\\\\:0\\\\]{border:0}.\\\\[bottom\\\\:20px\\\\]{bottom:20px}.\\\\[cursor\\\\:pointer\\\\]{cursor:pointer}.\\\\[display\\\\:flex\\\\]{display:flex}.\\\\[flex\\\\:1\\\\]{flex:1}.\\\\[font-family\\\\:inherit\\\\]{font-family:inherit}.\\\\[font-size\\\\:16px\\\\]{font-size:16px}.\\\\[font-size\\\\:18px\\\\]{font-size:18px}.\\\\[height\\\\:32px\\\\]{height:32px}.\\\\[height\\\\:40vh\\\\]{height:40vh}.\\\\[justify-content\\\\:center\\\\]{justify-content:center}.\\\\[margin-inline\\\\:auto\\\\]{margin-inline:auto}.\\\\[position\\\\:absolute\\\\]{position:absolute}.\\\\!\\\\[position\\\\:relative\\\\]{position:relative!important}.\\\\[width\\\\:100\\\\%\\\\]{width:100%}.\\\\[width\\\\:32px\\\\]{width:32px}.\\\\[width\\\\:60\\\\%\\\\]{width:60%}.disabled\\\\:\\\\[cursor\\\\:default\\\\]:disabled{cursor:default}.disabled\\\\:\\\\[opacity\\\\:20\\\\%\\\\]:disabled{opacity:20%}.\\\\[\\\\&\\\\~section\\\\:first-of-type\\\\]\\\\:\\\\[margin-top\\\\:16px\\\\]~section:first-of-type{margin-top:16px}.\\\\[\\\\&\\\\~section\\\\:last-of-type\\\\]\\\\:\\\\[margin-bottom\\\\:16px\\\\]~section:last-of-type{margin-bottom:16px}\";\nstyleInject(css_248z,{\"insertAt\":\"top\"});\n\nconst openProp = compareVersions(version, '4.23.0') === -1 ? 'visible' : 'open';\nconst deprecate = (obj, old, now) => {\n    if (old in obj) {\n        console.error(`\\`${old}\\` is deprecated, please use \\`${now}\\` instead`);\n        return obj[old];\n    }\n    return obj[now];\n};\nconst ImgCrop = forwardRef((props, cropperRef) => {\n    const { quality = 0.4, fillColor = 'white', \n    // @ts-ignore\n    zoomSlider: ZOOM_SLIDER = true, \n    // @ts-ignore\n    rotationSlider: ROTATION_SLIDER = false, aspectSlider = false, showReset = false, resetText, aspect = 1, minZoom = 1, maxZoom = 3, \n    // @ts-ignore\n    cropShape: CROP_SHAPE = 'rect', \n    // @ts-ignore\n    showGrid: SHOW_GRID = false, cropperProps, modalClassName, modalTitle, modalWidth, modalOk, modalCancel, onModalOk, onModalCancel, modalProps, beforeCrop, children, } = props;\n    /**\n     * init\n     */\n    const zoomSlider = deprecate(props, 'zoom', 'zoomSlider') || true;\n    const rotationSlider = deprecate(props, 'rotate', 'rotationSlider') || false;\n    const cropShape = deprecate(props, 'shape', 'cropShape') || 'rect';\n    const showGrid = deprecate(props, 'grid', 'showGrid') || false;\n    if ('onUploadFail' in props) {\n        console.error(`\\`onUploadFail\\` is removed, because the only way it is called, is when the file is rejected by beforeUpload`);\n    }\n    deprecate(props, 'modalMaskTransitionName', 'modalProps.maskTransitionName');\n    deprecate(props, 'modalTransitionName', 'modalProps.transitionName');\n    const cb = useRef({});\n    cb.current.onModalOk = onModalOk;\n    cb.current.onModalCancel = onModalCancel;\n    cb.current.beforeCrop = beforeCrop;\n    /**\n     * crop\n     */\n    const easyCropRef = useRef(null);\n    const getCropCanvas = useCallback((target) => {\n        var _a;\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        const context = ((_a = target === null || target === void 0 ? void 0 : target.getRootNode) === null || _a === void 0 ? void 0 : _a.call(target)) || document;\n        const imgSource = context.querySelector(`.${PREFIX}-media`);\n        const { width: cropWidth, height: cropHeight, x: cropX, y: cropY, } = easyCropRef.current.cropPixelsRef.current;\n        if (rotationSlider &&\n            easyCropRef.current.rotation !== ROTATION_INITIAL) {\n            const { naturalWidth: imgWidth, naturalHeight: imgHeight } = imgSource;\n            const angle = easyCropRef.current.rotation * (Math.PI / 180);\n            // get container for rotated image\n            const sine = Math.abs(Math.sin(angle));\n            const cosine = Math.abs(Math.cos(angle));\n            const squareWidth = imgWidth * cosine + imgHeight * sine;\n            const squareHeight = imgHeight * cosine + imgWidth * sine;\n            canvas.width = squareWidth;\n            canvas.height = squareHeight;\n            ctx.fillStyle = fillColor;\n            ctx.fillRect(0, 0, squareWidth, squareHeight);\n            // rotate container\n            const squareHalfWidth = squareWidth / 2;\n            const squareHalfHeight = squareHeight / 2;\n            ctx.translate(squareHalfWidth, squareHalfHeight);\n            ctx.rotate(angle);\n            ctx.translate(-squareHalfWidth, -squareHalfHeight);\n            // draw rotated image\n            const imgX = (squareWidth - imgWidth) / 2;\n            const imgY = (squareHeight - imgHeight) / 2;\n            ctx.drawImage(imgSource, 0, 0, imgWidth, imgHeight, imgX, imgY, imgWidth, imgHeight);\n            // crop rotated image\n            const imgData = ctx.getImageData(0, 0, squareWidth, squareHeight);\n            canvas.width = cropWidth;\n            canvas.height = cropHeight;\n            ctx.putImageData(imgData, -cropX, -cropY);\n        }\n        else {\n            canvas.width = cropWidth;\n            canvas.height = cropHeight;\n            ctx.fillStyle = fillColor;\n            ctx.fillRect(0, 0, cropWidth, cropHeight);\n            ctx.drawImage(imgSource, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);\n        }\n        return canvas;\n    }, [fillColor, rotationSlider]);\n    /**\n     * upload\n     */\n    const [modalImage, setModalImage] = useState('');\n    const onCancel = useRef();\n    const onOk = useRef();\n    const runBeforeUpload = useCallback((_a) => __awaiter(void 0, [_a], void 0, function* ({ beforeUpload, file, resolve, reject, }) {\n        const rawFile = file;\n        if (typeof beforeUpload !== 'function') {\n            resolve(rawFile);\n            return;\n        }\n        try {\n            // https://ant.design/components/upload-cn#api\n            // https://github.com/ant-design/ant-design/blob/master/components/upload/Upload.tsx#L152-L178\n            const result = yield beforeUpload(file, [file]);\n            if (result === false) {\n                resolve(false);\n            }\n            else {\n                resolve((result !== true && result) || rawFile);\n            }\n        }\n        catch (err) {\n            reject(err);\n        }\n    }), []);\n    const getNewBeforeUpload = useCallback((beforeUpload) => {\n        return ((file, fileList) => {\n            return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\n                let processedFile = file;\n                if (typeof cb.current.beforeCrop === 'function') {\n                    try {\n                        const result = yield cb.current.beforeCrop(file, fileList);\n                        if (result === false) {\n                            return runBeforeUpload({ beforeUpload, file, resolve, reject }); // not open modal\n                        }\n                        if (result !== true) {\n                            processedFile = result || file; // will open modal\n                        }\n                    }\n                    catch (err) {\n                        return runBeforeUpload({ beforeUpload, file, resolve, reject }); // not open modal\n                    }\n                }\n                // read file\n                const reader = new FileReader();\n                reader.addEventListener('load', () => {\n                    if (typeof reader.result === 'string') {\n                        setModalImage(reader.result); // open modal\n                    }\n                });\n                reader.readAsDataURL(processedFile);\n                // on modal cancel\n                onCancel.current = () => {\n                    var _a, _b;\n                    setModalImage('');\n                    easyCropRef.current.onReset();\n                    let hasResolveCalled = false;\n                    (_b = (_a = cb.current).onModalCancel) === null || _b === void 0 ? void 0 : _b.call(_a, (LIST_IGNORE) => {\n                        resolve(LIST_IGNORE);\n                        hasResolveCalled = true;\n                    });\n                    if (!hasResolveCalled) {\n                        resolve(AntUpload.LIST_IGNORE);\n                    }\n                };\n                // on modal confirm\n                onOk.current = (event) => __awaiter(void 0, void 0, void 0, function* () {\n                    setModalImage('');\n                    easyCropRef.current.onReset();\n                    const canvas = getCropCanvas(event.target);\n                    const { type, name, uid } = processedFile;\n                    canvas.toBlob((blob) => __awaiter(void 0, void 0, void 0, function* () {\n                        const newFile = new File([blob], name, { type });\n                        Object.assign(newFile, { uid });\n                        runBeforeUpload({\n                            beforeUpload,\n                            file: newFile,\n                            resolve: (file) => {\n                                var _a, _b;\n                                resolve(file);\n                                (_b = (_a = cb.current).onModalOk) === null || _b === void 0 ? void 0 : _b.call(_a, file);\n                            },\n                            reject: (err) => {\n                                var _a, _b;\n                                reject(err);\n                                (_b = (_a = cb.current).onModalOk) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n                            },\n                        });\n                    }), type, quality);\n                });\n            }));\n        });\n    }, [getCropCanvas, quality, runBeforeUpload]);\n    const getNewUpload = useCallback((children) => {\n        const upload = Array.isArray(children) ? children[0] : children;\n        const _a = upload.props, { beforeUpload, accept } = _a, restUploadProps = __rest(_a, [\"beforeUpload\", \"accept\"]);\n        return Object.assign(Object.assign({}, upload), { props: Object.assign(Object.assign({}, restUploadProps), { accept: accept || 'image/*', beforeUpload: getNewBeforeUpload(beforeUpload) }) });\n    }, [getNewBeforeUpload]);\n    /**\n     * modal\n     */\n    const modalBaseProps = useMemo(() => {\n        const obj = {};\n        if (modalWidth !== undefined)\n            obj.width = modalWidth;\n        if (modalOk !== undefined)\n            obj.okText = modalOk;\n        if (modalCancel !== undefined)\n            obj.cancelText = modalCancel;\n        return obj;\n    }, [modalCancel, modalOk, modalWidth]);\n    const wrapClassName = `${PREFIX}-modal${modalClassName ? ` ${modalClassName}` : ''}`;\n    const lang = typeof window === 'undefined' ? '' : window.navigator.language;\n    const isCN = lang === 'zh-CN';\n    const title = modalTitle || (isCN ? '编辑图片' : 'Edit image');\n    const resetBtnText = resetText || (isCN ? '重置' : 'Reset');\n    return (jsxs(Fragment, { children: [getNewUpload(children), modalImage && (jsx(AntModal, Object.assign({}, modalProps, modalBaseProps, { [openProp]: true, title: title, onCancel: onCancel.current, onOk: onOk.current, wrapClassName: wrapClassName, maskClosable: false, destroyOnClose: true, children: jsx(EasyCrop$1, { ref: easyCropRef, cropperRef: cropperRef, zoomSlider: zoomSlider, rotationSlider: rotationSlider, aspectSlider: aspectSlider, showReset: showReset, resetBtnText: resetBtnText, modalImage: modalImage, aspect: aspect, minZoom: minZoom, maxZoom: maxZoom, cropShape: cropShape, showGrid: showGrid, cropperProps: cropperProps }) })))] }));\n});\n\nexport { ImgCrop as default };\n", "/**\n * Allowed arithmetic operators\n */\nexport type CompareOperator = '>' | '>=' | '=' | '<' | '<=' | '!=';\n\nexport const semver =\n  /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nexport const validateAndParse = (version: string) => {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n  const match = version.match(semver);\n  if (!match) {\n    throw new Error(\n      `Invalid argument not valid semver ('${version}' received)`\n    );\n  }\n  match.shift();\n  return match;\n};\n\nconst isWildcard = (s: string) => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = (v: string) => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a: string | number, b: string | number) =>\n  typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a: string, b: string) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nexport const compareSegments = (\n  a: string | string[] | RegExpMatchArray,\n  b: string | string[] | RegExpMatchArray\n) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n  return 0;\n};\n", "import { compareSegments, validateAndParse } from './utils';\n\n/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nexport const compareVersions = (v1: string, v2: string) => {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2);\n\n  // pop off the patch\n  const p1 = n1.pop();\n  const p2 = n2.pop();\n\n  // validate numbers\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r;\n\n  // validate pre-release\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n};\n", "import { compareVersions } from './compareVersions';\nimport { CompareOperator } from './utils';\n\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\nexport const compare = (v1: string, v2: string, operator: CompareOperator) => {\n  // validate input operator\n  assertValidOperator(operator);\n\n  // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n  const res = compareVersions(v1, v2);\n\n  return operatorResMap[operator].includes(res);\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1],\n  '!=': [-1, 1],\n};\n\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = (op: string) => {\n  if (typeof op !== 'string') {\n    throw new TypeError(\n      `Invalid operator type, expected string but got ${typeof op}`\n    );\n  }\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\n      `Invalid operator, expected one of ${allowedOperators.join('|')}`\n    );\n  }\n};\n", "import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = rotateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Compute media zoom.\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\n */\nexport function getMediaZoom(mediaSize: MediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height\n    ? mediaSize.width / mediaSize.naturalWidth\n    : mediaSize.height / mediaSize.naturalHeight\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n\n  return clamp(position, -maxPosition, maxPosition)\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition ? limitArea : noOp\n\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  // calculate the crop area in percentages\n  // in the rotated space\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width) *\n        100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) /\n        mediaBBoxSize.height) *\n        100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaBBoxSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaBBoxSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.width,\n      (croppedAreaPercentages.width * mediaNaturalBBoxSize.width) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.height,\n      (croppedAreaPercentages.height * mediaNaturalBBoxSize.height) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.width - sizePixels.width,\n        (croppedAreaPercentages.x * mediaNaturalBBoxSize.width) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.height - sizePixels.height,\n        (croppedAreaPercentages.y * mediaNaturalBBoxSize.height) / 100\n      )\n    ),\n  }\n\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPercentages.\n */\nexport function getInitialCropFromCroppedAreaPercentages(\n  croppedAreaPercentages: Area,\n  mediaSize: MediaSize,\n  rotation: number,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n) {\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  // This is the inverse process of computeCroppedArea\n  const zoom = clamp(\n    (cropSize.width / mediaBBoxSize.width) * (100 / croppedAreaPercentages.width),\n    minZoom,\n    maxZoom\n  )\n\n  const crop = {\n    x:\n      (zoom * mediaBBoxSize.width) / 2 -\n      cropSize.width / 2 -\n      mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y:\n      (zoom * mediaBBoxSize.height) / 2 -\n      cropSize.height / 2 -\n      mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100),\n  }\n\n  return { crop, zoom }\n}\n\n/**\n * Compute zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize: Size\n): number {\n  const mediaZoom = getMediaZoom(mediaSize)\n\n  return cropSize.height > cropSize.width\n    ? cropSize.height / (croppedAreaPixels.height * mediaZoom)\n    : cropSize.width / (croppedAreaPixels.width * mediaZoom)\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  rotation = 0,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n): { crop: Point; zoom: number } {\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  const zoom = clamp(\n    getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize),\n    minZoom,\n    maxZoom\n  )\n\n  const cropZoom =\n    cropSize.height > cropSize.width\n      ? cropSize.height / croppedAreaPixels.height\n      : cropSize.width / croppedAreaPixels.width\n\n  const crop = {\n    x:\n      ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y:\n      ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) *\n      cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\nexport function getRadianAngle(degreeValue: number) {\n  return (degreeValue * Math.PI) / 180\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function rotateSize(width: number, height: number, rotation: number): Size {\n  const rotRad = getRadianAngle(rotation)\n\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\n  }\n}\n\n/**\n * Clamp value between min and max\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter((value) => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n", "import * as React from 'react'\nimport normalizeWheel from 'normalize-wheel'\nimport { Area, MediaSize, Point, Size, VideoSrc } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  getInitialCropFromCroppedAreaPercentages,\n  classNames,\n  clamp,\n} from './helpers'\nimport cssStyles from './styles.css'\n\nexport type CropperProps = {\n  image?: string\n  video?: string | VideoSrc[]\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  objectFit?: 'contain' | 'cover' | 'horizontal-cover' | 'vertical-cover'\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n  initialCroppedAreaPixels?: Area\n  initialCroppedAreaPercentages?: Area\n  onTouchRequest?: (e: React.TouchEvent<HTMLDivElement>) => boolean\n  onWheelRequest?: (e: WheelEvent) => boolean\n  setImageRef?: (ref: React.RefObject<HTMLImageElement>) => void\n  setVideoRef?: (ref: React.RefObject<HTMLVideoElement>) => void\n  setMediaSize?: (size: MediaSize) => void\n  setCropSize?: (size: Size) => void\n  nonce?: string\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n  mediaObjectFit: String | undefined\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\ntype GestureEvent = UIEvent & {\n  rotation: number\n  scale: number\n  clientX: number\n  clientY: number\n}\n\nclass Cropper extends React.Component<CropperProps, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect' as const,\n    objectFit: 'contain' as const,\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: React.RefObject<HTMLImageElement> = React.createRef()\n  videoRef: React.RefObject<HTMLVideoElement> = React.createRef()\n  containerPosition: Point = { x: 0, y: 0 }\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  gestureZoomStart = 0\n  gestureRotationStart = 0\n  isTouching = false\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n  currentDoc: Document | null = typeof document !== 'undefined' ? document : null\n  currentWindow: Window | null = typeof window !== 'undefined' ? window : null\n  resizeObserver: ResizeObserver | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n    mediaObjectFit: undefined,\n  }\n\n  componentDidMount() {\n    if (!this.currentDoc || !this.currentWindow) return\n    if (this.containerRef) {\n      if (this.containerRef.ownerDocument) {\n        this.currentDoc = this.containerRef.ownerDocument\n      }\n      if (this.currentDoc.defaultView) {\n        this.currentWindow = this.currentDoc.defaultView\n      }\n\n      this.initResizeObserver()\n      // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant\n      if (typeof window.ResizeObserver === 'undefined') {\n        this.currentWindow.addEventListener('resize', this.computeSizes)\n      }\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.onGestureStart as EventListener)\n    }\n\n    this.currentDoc.addEventListener('scroll', this.onScroll)\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = this.currentDoc.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      if (this.props.nonce) {\n        this.styleRef.setAttribute('nonce', this.props.nonce)\n      }\n      this.styleRef.innerHTML = cssStyles\n      this.currentDoc.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef.current && this.imageRef.current.complete) {\n      this.onMediaLoad()\n    }\n\n    // set image and video refs in the parent if the callbacks exist\n    if (this.props.setImageRef) {\n      this.props.setImageRef(this.imageRef)\n    }\n\n    if (this.props.setVideoRef) {\n      this.props.setVideoRef(this.videoRef)\n    }\n  }\n\n  componentWillUnmount() {\n    if (!this.currentDoc || !this.currentWindow) return\n    if (typeof window.ResizeObserver === 'undefined') {\n      this.currentWindow.removeEventListener('resize', this.computeSizes)\n    }\n    this.resizeObserver?.disconnect()\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.parentNode?.removeChild(this.styleRef)\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: CropperProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.objectFit !== this.props.objectFit) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    } else if (\n      prevProps.crop?.x !== this.props.crop?.x ||\n      prevProps.crop?.y !== this.props.crop?.y\n    ) {\n      this.emitCropAreaChange()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n    if (prevProps.video !== this.props.video) {\n      this.videoRef.current?.load()\n    }\n\n    const objectFit = this.getObjectFit()\n    if (objectFit !== this.state.mediaObjectFit) {\n      this.setState({ mediaObjectFit: objectFit }, this.computeSizes)\n    }\n  }\n\n  initResizeObserver = () => {\n    if (typeof window.ResizeObserver === 'undefined' || !this.containerRef) {\n      return\n    }\n    let isFirstResize = true\n    this.resizeObserver = new window.ResizeObserver((entries) => {\n      if (isFirstResize) {\n        isFirstResize = false // observe() is called on mount, we don't want to trigger a recompute on mount\n        return\n      }\n      this.computeSizes()\n    })\n    this.resizeObserver.observe(this.containerRef)\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    if (!this.currentDoc) return\n    this.currentDoc.removeEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.removeEventListener('mouseup', this.onDragStopped)\n    this.currentDoc.removeEventListener('touchmove', this.onTouchMove)\n    this.currentDoc.removeEventListener('touchend', this.onDragStopped)\n    this.currentDoc.removeEventListener('gesturemove', this.onGestureMove as EventListener)\n    this.currentDoc.removeEventListener('gestureend', this.onGestureEnd as EventListener)\n    this.currentDoc.removeEventListener('scroll', this.onScroll)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    const cropSize = this.computeSizes()\n\n    if (cropSize) {\n      this.emitCropData()\n      this.setInitialCrop(cropSize)\n    }\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = (cropSize: Size) => {\n    if (this.props.initialCroppedAreaPercentages) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPercentages(\n        this.props.initialCroppedAreaPercentages,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    } else if (this.props.initialCroppedAreaPixels) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n        this.props.initialCroppedAreaPixels,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    }\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  getObjectFit() {\n    if (this.props.objectFit === 'cover') {\n      const mediaRef = this.imageRef.current || this.videoRef.current\n\n      if (mediaRef && this.containerRef) {\n        this.containerRect = this.containerRef.getBoundingClientRect()\n        const containerAspect = this.containerRect.width / this.containerRect.height\n        const naturalWidth =\n          this.imageRef.current?.naturalWidth || this.videoRef.current?.videoWidth || 0\n        const naturalHeight =\n          this.imageRef.current?.naturalHeight || this.videoRef.current?.videoHeight || 0\n        const mediaAspect = naturalWidth / naturalHeight\n\n        return mediaAspect < containerAspect ? 'horizontal-cover' : 'vertical-cover'\n      }\n      return 'horizontal-cover'\n    }\n\n    return this.props.objectFit\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef.current || this.videoRef.current\n\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n      this.saveContainerPosition()\n      const containerAspect = this.containerRect.width / this.containerRect.height\n      const naturalWidth =\n        this.imageRef.current?.naturalWidth || this.videoRef.current?.videoWidth || 0\n      const naturalHeight =\n        this.imageRef.current?.naturalHeight || this.videoRef.current?.videoHeight || 0\n      const isMediaScaledDown =\n        mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight\n      const mediaAspect = naturalWidth / naturalHeight\n\n      // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n      // as the values they report are rounded. That will result in precision losses\n      // when calculating zoom. We use the fact that the media is positionned relative\n      // to the container. That allows us to use the container's dimensions\n      // and natural aspect ratio of the media to calculate accurate media size.\n      // However, for this to work, the container should not be rotated\n      let renderedMediaSize: Size\n\n      if (isMediaScaledDown) {\n        switch (this.state.mediaObjectFit) {\n          default:\n          case 'contain':\n            renderedMediaSize =\n              containerAspect > mediaAspect\n                ? {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n                : {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n            break\n          case 'horizontal-cover':\n            renderedMediaSize = {\n              width: this.containerRect.width,\n              height: this.containerRect.width / mediaAspect,\n            }\n            break\n          case 'vertical-cover':\n            renderedMediaSize = {\n              width: this.containerRect.height * mediaAspect,\n              height: this.containerRect.height,\n            }\n            break\n        }\n      } else {\n        renderedMediaSize = {\n          width: mediaRef.offsetWidth,\n          height: mediaRef.offsetHeight,\n        }\n      }\n\n      this.mediaSize = {\n        ...renderedMediaSize,\n        naturalWidth,\n        naturalHeight,\n      }\n\n      // set media size in the parent\n      if (this.props.setMediaSize) {\n        this.props.setMediaSize(this.mediaSize)\n      }\n\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            this.mediaSize.width,\n            this.mediaSize.height,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n      this.setState({ cropSize }, this.recomputeCropPosition)\n      // pass crop size to parent\n      if (this.props.setCropSize) {\n        this.props.setCropSize(cropSize)\n      }\n\n      return cropSize\n    }\n  }\n\n  saveContainerPosition = () => {\n    if (this.containerRef) {\n      const bounds = this.containerRef.getBoundingClientRect()\n      this.containerPosition = { x: bounds.left, y: bounds.top }\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent | GestureEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.currentDoc.addEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.addEventListener('mouseup', this.onDragStopped)\n    this.saveContainerPosition()\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onScroll = (e: Event) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.saveContainerPosition()\n  }\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    if (!this.currentDoc) return\n    this.isTouching = true\n    if (this.props.onTouchRequest && !this.props.onTouchRequest(e)) {\n      return\n    }\n\n    this.currentDoc.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    this.currentDoc.addEventListener('touchend', this.onDragStopped)\n\n    this.saveContainerPosition()\n\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onGestureStart = (e: GestureEvent) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.currentDoc.addEventListener('gesturechange', this.onGestureMove as EventListener)\n    this.currentDoc.addEventListener('gestureend', this.onGestureEnd as EventListener)\n    this.gestureZoomStart = this.props.zoom\n    this.gestureRotationStart = this.props.rotation\n  }\n\n  onGestureMove = (e: GestureEvent) => {\n    e.preventDefault()\n    if (this.isTouching) {\n      // this is to avoid conflict between gesture and touch events\n      return\n    }\n\n    const point = Cropper.getMousePoint(e)\n    const newZoom = this.gestureZoomStart - 1 + e.scale\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n    if (this.props.onRotationChange) {\n      const newRotation = this.gestureRotationStart + e.rotation\n      this.props.onRotationChange(newRotation)\n    }\n  }\n\n  onGestureEnd = (e: GestureEvent) => {\n    this.cleanEvents()\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (!this.currentWindow) return\n    if (this.rafDragTimeout) this.currentWindow.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = this.currentWindow.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.isTouching = false\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    if (!this.currentDoc || !this.currentWindow) return\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center, { shouldUpdatePosition: false })\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    if (!this.currentWindow) return\n    if (this.props.onWheelRequest && !this.props.onWheelRequest(e)) {\n      return\n    }\n\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const { pixelY } = normalizeWheel(e)\n    const newZoom = this.props.zoom - (pixelY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = this.currentWindow.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point, containerTopLeft: Point): Point => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - containerTopLeft.x),\n      y: this.containerRect.height / 2 - (y - containerTopLeft.y),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point, { shouldUpdatePosition = true } = {}) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const newZoom = clamp(zoom, this.props.minZoom, this.props.maxZoom)\n\n    if (shouldUpdatePosition) {\n      const zoomPoint = this.getPointOnContainer(point, this.containerPosition)\n      const zoomTarget = this.getPointOnMedia(zoomPoint)\n      const requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            newZoom,\n            this.props.rotation\n          )\n        : requestedPosition\n\n      this.props.onCropChange(newPosition)\n    }\n    this.props.onZoomChange(newZoom)\n  }\n\n  getCropData = () => {\n    if (!this.state.cropSize) {\n      return null\n    }\n\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    return computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n  }\n\n  emitCropData = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropComplete) {\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n    }\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  emitCropAreaChange = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n    } = this.props\n\n    const objectFit = this.state.mediaObjectFit ?? this.getObjectFit()\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={(el) => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames(\n              'reactEasyCrop_Image',\n              objectFit === 'contain' && 'reactEasyCrop_Contain',\n              objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n              objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n              mediaClassName\n            )}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={this.imageRef}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              playsInline\n              loop\n              muted={true}\n              className={classNames(\n                'reactEasyCrop_Video',\n                objectFit === 'contain' && 'reactEasyCrop_Contain',\n                objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n                objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n                mediaClassName\n              )}\n              {...mediaProps}\n              ref={this.videoRef}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            >\n              {(Array.isArray(video) ? video : [{ src: video }]).map((item) => (\n                <source key={item.src} {...item} />\n              ))}\n            </video>\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"],
>>>>>>> 87a3c59de976df81a8c3db99a25f15e458e1b222
  "mappings": "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",
  "names": ["normalizeWheel", "getCropSize", "mediaWidth", "mediaHeight", "containerWidth", "containerHeight", "aspect", "rotation", "_a", "rotateSize", "width", "height", "fittingWidth", "Math", "min", "fittingHeight", "getMediaZoom", "mediaSize", "naturalWidth", "naturalHeight", "restrictPosition", "position", "cropSize", "zoom", "x", "restrictPositionCoord", "y", "maxPosition", "clamp", "getDistanceBetweenPoints", "pointA", "pointB", "sqrt", "pow", "getRotationBetweenPoints", "atan2", "PI", "computeCroppedArea", "crop", "limitAreaFn", "limitArea", "noOp", "mediaBBoxSize", "mediaNaturalBBoxSize", "croppedAreaPercentages", "widthInPixels", "round", "heightInPixels", "isImgWiderThanHigh", "sizePixels", "croppedAreaPixels", "__assign", "max", "value", "_max", "getInitialCropFromCroppedAreaPercentages", "minZoom", "maxZoom", "getZoomFromCroppedAreaPixels", "mediaZoom", "getInitialCropFromCroppedAreaPixels", "cropZoom", "getCenter", "a", "b", "getRadianAngle", "degreeValue", "rotRad", "abs", "cos", "sin", "classNames", "args", "_i", "arguments", "length", "filter", "join", "trim", "MIN_ZOOM", "MAX_ZOOM", "Cropper", "_super", "__extends", "_this", "apply", "imageRef", "createRef", "videoRef", "containerPosition", "containerRef", "styleRef", "containerRect", "dragStartPosition", "dragStartCrop", "gestureZoomStart", "gestureRotationStart", "isTouching", "lastPinchDistance", "lastPinchRotation", "rafDragTimeout", "rafPinchTimeout", "wheelTimer", "currentDoc", "document", "currentWindow", "window", "resizeObserver", "state", "hasWheelJustStarted", "mediaObjectFit", "undefined", "initResizeObserver", "ResizeObserver", "isFirstResize", "entries", "computeSizes", "observe", "preventZoomSafari", "e", "preventDefault", "cleanEvents", "removeEventListener", "onMouseMove", "onDragStopped", "onTouchMove", "onGestureMove", "onGestureEnd", "onScroll", "clearScrollEvent", "onWheel", "clearTimeout", "onMediaLoad", "emitCropData", "setInitialCrop", "props", "onMediaLoaded", "initialCroppedAreaPercentages", "onCropChange", "onZoomChange", "initialCroppedAreaPixels", "_b", "mediaRef", "current", "getBoundingClientRect", "saveContainerPosition", "containerAspect", "videoWidth", "_c", "_d", "videoHeight", "isMediaScaledDown", "offsetWidth", "offsetHeight", "mediaAspect", "renderedMediaSize", "setMediaSize", "_e", "_f", "onCropSizeChange", "setState", "recomputeCropPosition", "setCropSize", "bounds", "left", "top", "onMouseDown", "addEventListener", "onDragStart", "getMousePoint", "onDrag", "onTouchStart", "onTouchRequest", "passive", "touches", "onPinchStart", "getTouchPoint", "onPinchMove", "onGestureStart", "point", "newZoom", "scale", "setNewZoom", "shouldUpdatePosition", "onRotationChange", "newRotation", "onInteractionStart", "cancelAnimationFrame", "requestAnimationFrame", "offsetX", "offsetY", "requestedPosition", "newPosition", "onInteractionEnd", "onWheelRequest", "pixelY", "normalizeWheel", "zoomSpeed", "call", "setTimeout", "getPointOnContainer", "containerTopLeft", "Error", "getPointOnMedia", "zoomPoint", "zoomTarget", "getCropData", "restrictedPosition", "getAspect", "cropData", "onCropComplete", "onCropAreaChange", "emitCropAreaChange", "prototype", "componentDidMount", "ownerDocument", "defaultView", "zoomWithScroll", "disableAutomaticStylesInjection", "createElement", "setAttribute", "nonce", "innerHTML", "cssStyles", "head", "appendChild", "complete", "setImageRef", "setVideoRef", "componentWillUnmount", "disconnect", "parentNode", "removeChild", "componentDidUpdate", "prevProps", "objectFit", "_g", "_h", "video", "_j", "load", "getObjectFit", "center", "distance", "render", "image", "mediaProps", "transform", "cropShape", "showGrid", "style", "containerStyle", "cropAreaStyle", "mediaStyle", "classes", "containerClassName", "cropAreaClassName", "mediaClassName", "ref", "el", "className", "React", "alt", "src", "concat", "onLoad", "autoPlay", "playsInline", "loop", "muted", "onLoadedMetadata", "controls", "Array", "isArray", "map", "item", "key", "defaultProps", "Number", "clientX", "clientY", "touch", "Component", "css_248z", "file", "children"]
}
